<HTML><HEAD><!--Revised: 1 Jan 1999 By: Pieter Hintjens-->
<TITLE>The SMT Kernel</TITLE></HEAD>
<BODY BACKGROUND="newstone.gif">
<TABLE WIDTH=100%><TR><TD ALIGN=LEFT>
 | <A HREF="/index.htm"> iMatix home page</A><BR>
 | <A href="smtdoc.htm">&lt;&lt;</A> | &lt;
 | &gt; | <A href="smtdoc.htm">&gt;&gt;</A>
<TD ALIGN=RIGHT>
<IMG SRC="smt100.gif" ALT="SMT Logo" WIDTH=80 HEIGHT=60 ALIGN=RIGHT HSPACE=10>
<FONT SIZE=5><B>SMT</B><BR><FONT SIZE=2>Version 2.81
</TABLE>
<HR>

<H1>The SMT Kernel</H1>

<P>The SMT (Simple Multi-Threading kernel) from iMatix is an
add-on for the <A href="/html/libero/">Libero</A> programming tool that lets you
write portable high-performance multithreaded programs based on
Libero's finite-state machine (FSM) design method.

<P>You may want to go straight to the <A href="smtdoc.htm#TOC">Table of Contents</A>.

<P>You can use the SMT kernel for:
<UL>
<LI>Internet programming: where each connection is handled by one
thread.
<LI>Real-time programming: where multilevel finite-state machines
work cooperatively.
<LI>GUI development: where events are collected from the GUI and
passed to threads for processing.
</UL>

<P>The SMT kernel's main features are:
<UL>
<LI>100% portability.
<LI>Strong object orientation.
<LI>Support for multiple FSM programs within one application.
<LI>Support for multiple threads within one FSM program.
<LI>Support for Internet protocols (TCP/IP, UDP/IP).
<LI>Based on Libero program development method.
<LI>Standard agents: http, file transfer, authorization,
logging, console, timing, socket i/o.
<LI>Unrestricted number of threads, queue sizes, etc.
</UL>

<P>The SMT kernel currently supports C/C++, and is written in
portable ANSI C.  It uses the iMatix <A href="/html/sfl/">SFL</A> (standard
function library) as a technical platform, and the <A href="/html/libero/">Libero</A>
tool as development method.  Libero, the SFL, and the SMT kernel
are provided as free software, copyrighted by iMatix.  You may
freely incorporate the SFL and SMT packages in your applications
with a minimum of conditions.  Read the <A href="smtdoc.htm#license">SMT license</A>
agreement for details.

<P>To use the SMT kernel you should have used Libero and
understand the concepts involved.  SMT applications are
essentially written using Libero.  We assume that the reader has
some familiarity with Libero.

<P>The SMT kernel has been ported to MS-DOS, Windows, UNIX systems
(Linux, IBM AIX, SunOS, HP/UX) and should be portable to Digital
VMS.  It comes with complete sources and documentation in HTML.
It includes XITAMI, a portable multithreaded web server.

<P>Send comments about the SMT kernel, bug reports, and submissions
to <A HREF="mailto:smt@imatix.com">smt@imatix.com</A>.

<A NAME="TOC">&nbsp;</A>
<H2>Table of Contents</H2>
<MENU>
<LI><A HREF="#TOC1">Introduction</A></LI>
<MENU>
<LI><A HREF="#TOC2">Origins</A></LI>
<LI><A HREF="#TOC3">Classic Multithreading Environments</A></LI>
<LI><A HREF="#TOC4">The History Of Libero Multithreading</A></LI>
<LI><A HREF="#TOC5">Differences with Classic Multithreading</A></LI>
<LI><A HREF="#TOC6">Why Use Multithreading?</A></LI>
<LI><A HREF="#TOC7">What You Should Know</A></LI>
</MENU>
<LI><A HREF="#TOC8">The SMT Kernel Architecture</A></LI>
<MENU>
<LI><A HREF="#TOC9">Structure Of An SMT Application</A></LI>
<LI><A HREF="#TOC10">Floating Event Queues</A></LI>
<LI><A HREF="#TOC11">Routers</A></LI>
<LI><A HREF="#TOC12">Internal and External Events</A></LI>
<LI><A HREF="#TOC13">Event Management</A></LI>
<LI><A HREF="#TOC14">Priorities and Scheduling</A></LI>
<LI><A HREF="#TOC15">Native Programs Vs. Foreign Programs</A></LI>
<LI><A HREF="#TOC16">The SMT Kernel Meta-State-Machine</A></LI>
</MENU>
<LI><A HREF="#TOC17">Using The SMT Kernel API</A></LI>
<MENU>
<LI><A HREF="#TOC18">SMT Kernel Functions</A></LI>
<LI><A HREF="#TOC19">Initialisation and Termination</A></LI>
<LI><A HREF="#TOC20">Creating A Thread</A></LI>
<LI><A HREF="#TOC21">Sending and Receiving Events</A></LI>
<LI><A HREF="#TOC22">Sending An Initial Event To A Thread</A></LI>
<LI><A HREF="#TOC23">Event Lifespan and Acknowledgment</A></LI>
<LI><A HREF="#TOC24">Using Priorities</A></LI>
</MENU>
<LI><A HREF="#TOC25">Writing A Native SMT Program</A></LI>
<MENU>
<LI><A HREF="#TOC26">Initialising An agent</A></LI>
<LI><A HREF="#TOC27">The Thread Context Block</A></LI>
<LI><A HREF="#TOC28">Choosing Event Names</A></LI>
<LI><A HREF="#TOC29">Mechanics Of Event Delivery</A></LI>
<LI><A HREF="#TOC30">Waiting For An External Event</A></LI>
<LI><A HREF="#TOC31">Sending Structured Event Data</A></LI>
<LI><A HREF="#TOC32">Sending Events Within An Agent</A></LI>
<LI><A HREF="#TOC33">Ignoring External Events</A></LI>
<LI><A HREF="#TOC34">Non-Blocking File Access</A></LI>
<LI><A HREF="#TOC35">Real-time Programming</A></LI>
<LI><A HREF="#TOC36">Using Semaphores</A></LI>
<LI><A HREF="#TOC37">Replacing The Standard Agents</A></LI>
</MENU>
<LI><A HREF="#TOC38">Using The SMT API In A Foreign Program</A></LI>
<MENU>
<LI><A HREF="#TOC39">Writing A Stub Program</A></LI>
<LI><A HREF="#TOC40">Managing A Floating Event Queue</A></LI>
<LI><A HREF="#TOC41">Executing The Application</A></LI>
</MENU>
<LI><A HREF="#TOC42">Standard SMT Agents</A></LI>
<MENU>
<LI><A HREF="#TOC43">The Logging Agent - SMTLOG</A></LI>
<LI><A HREF="#TOC44">The Operator Console Agent - SMTOPER</A></LI>
<LI><A HREF="#TOC45">The Timer Agent - SMTTIME</A></LI>
<LI><A HREF="#TOC46">The Time Slot Agent - SMTSLOT</A></LI>
<LI><A HREF="#TOC47">The Socket I/O Agent - SMTSOCK</A></LI>
<LI><A HREF="#TOC48">The Transfer Agent - SMTTRAN</A></LI>
<LI><A HREF="#TOC49">The TCP ECHO Agent - SMTECHO</A></LI>
<LI><A HREF="#TOC50">The HTTP Agent - SMTHTTP</A></LI>
<LI><A HREF="#TOC51">The Network Delay Simulation Agent - SMTSIMU</A></LI>
</MENU>
<LI><A HREF="#TOC52">SMT API Quick Reference</A></LI>
<LI><A HREF="#TOC53">The Unattended Process Monitor (UPM) Tool</A></LI>
<MENU>
<LI><A HREF="#TOC54">Overview</A></LI>
<LI><A HREF="#TOC55">Technical Details</A></LI>
<LI><A HREF="#TOC56">Using The UPM Tool</A></LI>
<LI><A HREF="#TOC57">UPM Trouble Shooting</A></LI>
</MENU>
<LI><A HREF="#TOC58">Installing The SMT Kernel</A></LI>
<MENU>
<LI><A HREF="#TOC59">Availability and Distribution</A></LI>
<LI><A HREF="#TOC60">Installation for UNIX Systems</A></LI>
<LI><A HREF="#TOC61">Installation for Digital VMS Systems</A></LI>
<LI><A HREF="#TOC62">Installation for Windows</A></LI>
</MENU>
<LI><A HREF="#TOC63">System-Specific Concerns</A></LI>
<MENU>
<LI><A HREF="#TOC64">Windows</A></LI>
</MENU>
<LI><A HREF="#TOC65">The SMT License Agreement</A></LI>
<LI><A HREF="#TOC66">SMT Kernel API functions</A></LI>
<MENU>
<LI><A HREF="#TOC67"><TT>smt_init</TT></A></LI>
<LI><A HREF="#TOC68"><TT>smt_term</TT></A></LI>
<LI><A HREF="#TOC69"><TT>smt_exec_full</TT></A></LI>
<LI><A HREF="#TOC70"><TT>smt_exec_step</TT></A></LI>
<LI><A HREF="#TOC71"><TT>smt_active</TT></A></LI>
<LI><A HREF="#TOC72"><TT>smt_set_console</TT></A></LI>
<LI><A HREF="#TOC73"><TT>smt_set_timer</TT></A></LI>
<LI><A HREF="#TOC74"><TT>smt_atexit</TT></A></LI>
<LI><A HREF="#TOC75"><TT>smt_shutdown</TT></A></LI>
<LI><A HREF="#TOC76"><TT>agent_declare</TT></A></LI>
<LI><A HREF="#TOC77"><TT>agent_lookup</TT></A></LI>
<LI><A HREF="#TOC78"><TT>agent_destroy</TT></A></LI>
<LI><A HREF="#TOC79"><TT>method_declare</TT></A></LI>
<LI><A HREF="#TOC80"><TT>method_lookup</TT></A></LI>
<LI><A HREF="#TOC81"><TT>method_destroy</TT></A></LI>
<LI><A HREF="#TOC82"><TT>queue_create</TT></A></LI>
<LI><A HREF="#TOC83"><TT>queue_lookup</TT></A></LI>
<LI><A HREF="#TOC84"><TT>queue_destroy</TT></A></LI>
<LI><A HREF="#TOC85"><TT>queue_deliver</TT></A></LI>
<LI><A HREF="#TOC86"><TT>queue_flush</TT></A></LI>
<LI><A HREF="#TOC87"><TT>event_send</TT></A></LI>
<LI><A HREF="#TOC88"><TT>event_accept</TT></A></LI>
<LI><A HREF="#TOC89"><TT>event_reject</TT></A></LI>
<LI><A HREF="#TOC90"><TT>event_expire</TT></A></LI>
<LI><A HREF="#TOC91"><TT>event_discard</TT></A></LI>
<LI><A HREF="#TOC92"><TT>event_iterate</TT></A></LI>
<LI><A HREF="#TOC93"><TT>event_destroy</TT></A></LI>
<LI><A HREF="#TOC94"><TT>event_wait</TT></A></LI>
<LI><A HREF="#TOC95"><TT>thread_create</TT></A></LI>
<LI><A HREF="#TOC96"><TT>thread_lookup</TT></A></LI>
<LI><A HREF="#TOC97"><TT>thread_destroy</TT></A></LI>
<LI><A HREF="#TOC98"><TT>semaph_create</TT></A></LI>
<LI><A HREF="#TOC99"><TT>semaph_lookup</TT></A></LI>
<LI><A HREF="#TOC100"><TT>semaph_destroy</TT></A></LI>
<LI><A HREF="#TOC101"><TT>semaph_wait</TT></A></LI>
<LI><A HREF="#TOC102"><TT>semaph_signal</TT></A></LI>
<LI><A HREF="#TOC103"><TT>lazy_creat</TT></A></LI>
<LI><A HREF="#TOC104"><TT>lazy_creat_text</TT></A></LI>
<LI><A HREF="#TOC105"><TT>lazy_open</TT></A></LI>
<LI><A HREF="#TOC106"><TT>lazy_open_text</TT></A></LI>
<LI><A HREF="#TOC107"><TT>lazy_read</TT></A></LI>
<LI><A HREF="#TOC108"><TT>lazy_write</TT></A></LI>
<LI><A HREF="#TOC109"><TT>lazy_close</TT></A></LI>
<LI><A HREF="#TOC110"><TT>senderr</TT></A></LI>
<LI><A HREF="#TOC111"><TT>sendfmt</TT></A></LI>
<LI><A HREF="#TOC112"><TT>raise_exception</TT></A></LI>
<LI><A HREF="#TOC113"><TT>recycle_module</TT></A></LI>
<LI><A HREF="#TOC114"><TT>smt_set_step</TT></A></LI>
<LI><A HREF="#TOC115"><TT>smt_crash_report</TT></A></LI>
</MENU>
<LI><A HREF="#TOC116">The Standard SMT Agents</A></LI>
<MENU>
<LI><A HREF="#TOC117"><TT>smtauth_init</TT></A></LI>
<LI><A HREF="#TOC118"><TT>smtecho_init</TT></A></LI>
<LI><A HREF="#TOC119"><TT>smthttp_init</TT></A></LI>
<LI><A HREF="#TOC120"><TT>smtftpc_init</TT></A></LI>
<LI><A HREF="#TOC121"><TT>smtftpd_init</TT></A></LI>
<LI><A HREF="#TOC122"><TT>smtrdns_init</TT></A></LI>
<LI><A HREF="#TOC123"><TT>smtlog_init</TT></A></LI>
<LI><A HREF="#TOC124"><TT>smtoper_init</TT></A></LI>
<LI><A HREF="#TOC125"><TT>smtslot_init</TT></A></LI>
<LI><A HREF="#TOC126"><TT>smtsock_init</TT></A></LI>
<LI><A HREF="#TOC127"><TT>smtsock_trace</TT></A></LI>
<LI><A HREF="#TOC128"><TT>smttime_init</TT></A></LI>
<LI><A HREF="#TOC129"><TT>smttran_init</TT></A></LI>
</MENU>
<LI><A HREF="#TOC130">The Network Delay Simulator</A></LI>
<MENU>
<LI><A HREF="#TOC131"><TT>smtsimu_init</TT></A></LI>
<LI><A HREF="#TOC132"><TT>smtsimu_sock_init</TT></A></LI>
<LI><A HREF="#TOC133"><TT>smtsimu_smtsock_init</TT></A></LI>
<LI><A HREF="#TOC134"><TT>smtsimu_smtsock_trace</TT></A></LI>
<LI><A HREF="#TOC135"><TT>smtsimu_write_UDP</TT></A></LI>
</MENU>
<LI><A HREF="#TOC136">The Unattended Process Monitor</A></LI>
<MENU>
<LI><A HREF="#TOC137"><TT>smtupmc_init</TT></A></LI>
</MENU>
</MENU>

<H2><A NAME="TOC1">Introduction</A></H2>

<H3><A NAME="TOC2">Origins</A></H3>

<P>SMT 2.0 is an evolution of SMT version 1.x of the iMatix SMT
kernel.  SMT 1.x was specifically designed for TCP/IP server
development.  SMT 2.x is a more generalised approach that makes
multithreaded FSMs suitable for a variety of purposes.  SMT 2.0 is
not backwards compatible with SMT 1.x, but it is quite
straight-forward to convert applications.

<P>The main objectives of SMT 1.0 were:
<OL>
<LI>Mulithreading - a cleaner and more efficient approach for
certain types of problems than alternatives such as
multiprocessing (forking) or iteration.
<LI>Simplicity - using the Libero method to simplify an otherwise
complex multithreaded model.
<LI>Portability - so that a SMT application runs on UNIX, Windows
95, Windows NT, and Digital VMS with similar functionality.
</OL>

<P>SMT 2.0 is meant to answer a wider set of issues. Specifically,
our goal was to provide multithreading capability in these domains:
<UL>
<LI>Internet servers
<LI>Other communication servers
<LI>Asynchronous FSM architectures
<LI>Internally multithreaded (batch) programs
<LI>GUI-based programs (e.g. Windows)
</UL>

<P>In SMT 1.x, external events were received and processed by a
kernel built-in to each SMT program.  The SMT 1.x kernel was
specifically designed to be driven by TCP/IP events.  An SMT 1.x
program is invoked, does its work, and finally terminates.  We
call this type of program a 'batch' program.  This is suitable for
servers ('daemons'), but not for real-time programs that must be
integrated into an large-scale event-driven architecture.

<P>SMT 2.x is designed as an event-passing kernel.  The
application consists of a number of agent programs, each running
one or more threads.  Each thread has an event queue.  Threads
send each other events, which are queued, and delivered by the
kernel to the state machine that controls each thread.  The SMT
kernel API lets you send and receive events, create threads, etc.
There are various ways to construct an agent program (single-
threaded, multithreaded), and different ways to handle event
queues (one thread per queue, or several threads per queue).
Agents and events can have priorities, which changes the order of
execution and delivery.

<P>SMT provides a number of standard agents that are easily reused
in applications.  For example, in an Internet application, the
socket i/o agent collects events from the Internet sockets used by
the application.  When a thread wants to read data from a socket,
it sends an event to the socket i/o agent, telling it which port,
and how much data.  The socket i/o agent reads the data and
returns that as a event.  Other standard agents are: a logging
agent to write log file data; an operator console agent to handle
error and warning events; a timer agent to generate alarm
events.<P>  <P>SMT also includes a number of protocol agents for
use in SMT applications: echo, HTTP, FTP.

<P>In SMT 1.x, external events such as TCP/IP events were
collected by the kernel, in SMT 2.x such events are collected by
an agent program.  Thus it is possible to add support to any
external event source.

<H3><A NAME="TOC3">Classic Multithreading Environments</A></H3>

<P>Multithreaded programming is often perceived as complicated.
When we look at multithreading facilities provided by existing
operating systems, we tend to agree. The most common type of
multithreading is <EM>pre-emptive multithreading</EM>.  This is
typically seen on UNIX and Windows NT systems.  The
characteristics of this approach are:
<UL>
<LI>The multithreading system (or operating system) switches
between threads arbitrarily.  This is 'pre-emptive'.
<LI>The thread program looks like standard procedural code.
<LI>Threads communicate using <EM>semaphores</EM>: when one thread
must wait for another, it sets a semaphore and then waits until
the second thread resets the semaphore.
<LI>Threads can access shared resources by using semaphores, or by
defining <EM>critical sections</EM>.  A critical section is a
block of code that executes entirely, without a thread
switch.
<LI>I/O is handled in critical sections.
</UL>

<P>A less common type of multithreading is <EM>cooperative
multithreading</EM>.  One example is the <EM>chained
multithreading</EM> method used on Digital VMS systems.  The
characteristics of this approach are:
<UL>
<LI>Each thread decides when to return control to the
multithreading system or operating system.
<LI>The thread program consists of a chain of small blocks of
code.
<LI>Threads can communicate using semaphores.
<LI>Threads can access shared resources at any time - threads
always execute as if in a critical section.
<LI>I/o is handled asynchronously: i/o operations are usually the
basic unit of logic in a thread.  Each block of code in a thread
requests an i/o operation, and specifies the successor block.
</UL>

<P>If we compare these methods, we can see advantages and
disadvantages in each:
<UL>
<LI>The chained method is much harder to program.
<LI>The chained method can produce much more efficient programs,
especially if they are i/o bound.
<LI>The pre-emptive method requires extra work to define critical
sections; it is not fail-safe.  By forgetting to define a critical
section, a program may work one day, then fail another time.  The
chained method does not require critical sections.
</UL>

<P>Both these methods are expensive to program, and can produce
code that is hard to maintain, error-prone, and therefore very
expensive to make robust enough for real applications.

<H3><A NAME="TOC4">The History Of Libero Multithreading</A></H3>

<P>In 1990, <A href="mailto:leif@ibm.net">Leif Svalgaard</A> wrote a tiny multitasking
monitor for MS-DOS, to demonstrate that multitasking did not
require megabytes of memory.  This monitor was based on an
event-passing kernel.  It worked well and could multitask several
DOS sessions simply and efficiently.  This project was remarkable
because it took a very short time to write (one long weekend) and
because it required so little memory to run (several kilobytes).
This monitor was based on Leif Svalgaard's earlier work in
operating systems design, and defined the core principles of the
SMT 2.x kernel.

<P>In 1993, Pieter Hintjens developed a complex multithreaded
application using the Digital VMS chained multithreading method.
Under severe time constraints, he was obliged to take a radical
alternative to the normal approach.  He used Libero to abstract
the 'chain' of multithreaded logic.  This reduced the development
cost by an estimated 80%, and resulted in a very stable and
efficient application.  This experience showed that the Libero
state-machine abstraction - already useful for writing normal
procedural code - was also good in multithreaded applications.

<P>In 1993, Christian Rozet and Stephen Bidoul of ACSE built a
version of Libero that generated a C++ 'asynchronous finite-state
machine' to handle events coming from a GUI (MS-Windows).  The
resulting applications were in effect multithreaded applications,
with the multithreading handled by Libero (actually the code that
Libero generated).

<P>In 1995, Pieter Hintjens and Pascal Antonnaux built SMT version
1.0, and a set of demonstration programs.  The <EM>smthttpd</EM>
web server ran on UNIX and Windows 95, showing that portable
multitasking was a realistic objective.

<P>SMT 2.0 is a fresh approach that combines the experience of
these projects:
<UL>
<LI>It is built on an event-based kernel that integrates smoothly
into the event-driven state machine inside each program.
<LI>It uses Libero to abstract the multithreading logic, so that
the application program is easy to write and maintain.
<LI>It can be oriented towards socket i/o (important for Internet
server programs), towards Windows event handling, or towards any
other event source.
</UL>

<H3><A NAME="TOC5">Differences with Classic Multithreading</A></H3>

<P>The main differences between SMT and 'classic' multithreading
are:
<UL>
<LI>Multithreading works at the user level, not the kernel level.
This is sometimes called 'internal multithreading' or 'pseudo-
multithreading'.  User-level multithreading is transparent to the
operating system, and can be 100% portable (as it is in SMT).
<LI>SMT cannot make direct use of multiple CPUs, since threads are
not visible to the operating system.
<LI>Threads communicate with events as well as with semaphores.
This is a clean abstraction that lets you design an
object-oriented application.
<LI>SMT is simpler to use.
<LI>SMT is portable to (almost) any operating system and
programming language, although the primary implementation is in
ANSI C.
</UL>

<P>We note some other points of interest:
<UL>
<LI>Thread switching occurs only between dialog action modules.  A
single dialog module will always run to completion.  Thus, threads
can share resources (data, files,...) without locking, critical
sections, or other special safeguards.
<LI>SMT provides a high-level framework for constructing real
applications.  This is useful even without the multithreading
aspects.
<LI>SMT uses asynchronous or non-blocking i/o as far as possible
- for Internet sockets and file access.  This results in efficient
applications that can handle large numbers of connections with a
low overhead per connection.
</UL>

<H3><A NAME="TOC6">Why Use Multithreading?</A></H3>

<P>We will consider two specific problems.  Firstly, construction
of an industrial-scale Internet server.  Secondly, construction of
a multi-level finite-state machine application.

<P>There are many different ways to design an Internet server.
The main problem is to handle multiple connections at once
('concurrency').  The classic way to get concurrency is to use the
operating system multitasking functions.  This is straight-forward
enough.  For instance, under UNIX, the server process uses the
fork() system call to create a 'clone' of itself. At any moment
there are multiple copies of the server process, each handling one
connection.  The operating system switches rapidly between these
processes, so giving concurrency.

<P>The problems with this design become apparent when you try to
use it for large-scale work.  Firstly, it is not portable - the
fork() system call does not work on all operating systems.
Secondly, each fork() call duplicates the server program in
memory.  This duplication takes a certain time, as does the
eventual removal of the server process.  A protocol like HTTP
creates a large number of short-term connections.  Lastly, each
additional instance of the server process consumes system
resources so that a typical system cannot handle more than a few
hundred connections.

<P>There are variations on this design that eliminate some of the
problems.  For instance, you can create a fixed number of
instances of the server beforehand, then allow that number of
connections.  This eliminates the cost of creating and removing
server processes, but does not raise the ceiling on the maximum
number of connections.

<P>A more sophisticated approach is to handle multiple connections
within a single process.  This is relatively simple to arrange,
using the BSD socket select() function.  This lets a program wait
for activity on a set of open sockets.  The logic of such a
program is: wait for activity on a socket; handle the activity;
repeat.  This approach works when the logic of 'handle the
activity' is simple.  In realistic applications, however, this
logic becomes complex, and involves activity such as reading or
writing to files, or manipulating several sockets at once.

<P>The SMT kernel uses the last approach, but provides a level of
abstraction that makes the approach practical for large-scale
problems.  You can create one or several 'threads'.  Each thread
executes a copy of the finite state machine.  The basic unit of
logic in a thread is the code module.

<P>The number of threads is limited only by the memory available
to the process.  Creating or removing a thread is fast (so a new
connection can be established faster than using a fork() call),
and as far as the operating system is concerned, there is just one
process (so the cost to the operating system is lower).

<P>Let's consider the design of an application that consists of
several interworking state machines.  This is the kind of design
one finds in telecommunications and other specialised domains.
The approach can be used in many areas.  Typically, such a state
machines processes an event queue; one state machine can send
events to another.

<P>In this type of design we need to save the 'state' of each
state machine in some way so that it can process events in a
meaningful manner.  The 'state' consists of the actual state, the
last event, and context information that the state machine program
needs to remember between events.  We can define this 'state' as a
thread: the requirements are very close to that of the Internet
server described above.  If we only want a single thread in any
state machine, we can consider this a special case of the general
case, which is a full multithreaded approach.

<P>Our conclusion from these two chains of argument is that a
state-machine approach to multithreading is useful and valuable in
real applications.  Since Libero already provides a state-machine
abstraction that converts a state-machine diagram into generated
code, it is reasonable to use this mechanism to implement a
generic and portable type of multithreading.

<P>The SMT 2.x kernel works with a specific Libero code generation
schema, smtschm.c, to provide this generic multithreading.

<H3><A NAME="TOC7">What You Should Know</A></H3>

<P>If you intend to write Internet servers, you should have a
basic understanding of the concepts behind IP, TCP/IP, and UDP/IP.
While the SMT kernel does a good job of packaging and abstracting
the Internet programming model, it is no substitute for a solid
understanding of the issues involved.  We recommend that you be
familiar with these aspects at least:
<UL>
<LI>The differences between TCP/IP and UDP/IP.
<LI>How TCP and UDP socket connections work.
<LI>The BSD socket programming interface.
</UL>
The SFL socket functions provide the main abstraction layer; for
instance you will not need to consider system-specific issues such
as the WINSOCK interface.

<P>Before designing or writing an SMT application you should
understand the Libero method of program design.  The main
components of an SMT application - the agents - are designed and
written using Libero.

<P>Before writing SMT applications you should be familiar with the
standard function library (SFL), since many SFL functions are used
in a typical SMT application.

<H2><A NAME="TOC8">The SMT Kernel Architecture</A></H2>

<H3><A NAME="TOC9">Structure Of An SMT Application</A></H3>

<P>An SMT application generally consists of a number of
<EM>agents</EM>, connected to the SMT kernel:

<PRE>
                     .------------.
                     : SMT kernel |
                     `============"
                            |
     - -+------------+------+-----+------------+- -
        |            |            |            |
    .-------.    .-------.    .-------.    .-------.
    : Agent |    : Agent |    : Agent |    : Agent |
    `======="    `======="    `======="    `======="

Figure: Regular SMT application
</PRE>

<P>We may also use an event driver to make an 'embedded
application'.  This is necessary when external events cannot be
collected by a normal SMT agent program such as the socket i/o
agent.  An example of such an application is one designed for MS
Windows.

<PRE>
                     .--------------.
                     : Event Driver |
                     `=============="
                            |
                     .------------.
                     : SMT kernel |
                     `============"
                            |
     - -+------------+------+-----+------------+- -
        |            |            |            |
    .-------.    .-------.    .-------.    .-------.
    : Agent |    : Agent |    : Agent |    : Agent |
    `======="    `======="    `======="    `======="

Figure: Embedded SMT application
</PRE>

<P>There are many other types of SMT application.  The SMT kernel
defines a number of objects, and operations on those objects.
These objects are arranged in a hierarchy: this is structural, not
morphological (they do not inherit attributes from each
other):

<PRE>
         Agent
           :            :  Method
         Queue
        /          Thread     Event

Figure: Main SMT Objects
</PRE>

<UL>
<LI>An SMT application consists of one or more <EM>agents</EM>.
An agent is written as a single program, based on one Libero
dialog definition (i.e. a finite state machine, or FSM).
<LI>An agent declares one or more <EM>methods</EM> that it can
process.  These are formal declarations of the <EM>events</EM>
that the agent is prepared to accept.  An agent that declares a
method "OPEN" will accept events called "OPEN".
<LI>An agent contains zero or more event <EM>queues</EM>.  When
you send an event somewhere, you send it to an event queue.
<LI>An event queue is handled by one or more <EM>threads</EM>.  A
thread is an instance of the finite-state machine program.
<LI>An event queue contains zero or more events.  These are events
waiting to be processed by the queue's thread(s).
<LI>Agents, methods, threads, and events are named.  Queues are
unnamed, and are referred-to by a <EM>queue id</EM> block, a token
that the SMT kernel generates when it creates a new queue.
</UL>

<P>The SMT holds these objects in a set of linked lists.  Each
thread, for instance, contains the reference of its parent queue;
a queue refers to its parent agent.

<PRE>
                      .------------.
                      : SMT kernel |
                      `============"
                             |
       -+-------------+------+------+-------------+-
        |             |             |             |
                  .-------.
                  : Agent |
                  `======="
                      |
        +-------------+-------------+
        |             |             |
    .--------.    .--------.    .--------.
    : Queue  |    : Queue  |    : Queue  |
    `========"    `========"    `========"
        |             |             |
    .--------.    .--------.    .--------.
    : Thread |    : Thread |    : Thread |
    `========"    `========"    `========"

Figure: Agent Program With 3 Threads
</PRE>

<H3><A NAME="TOC10">Floating Event Queues</A></H3>

<P>In normal cases, events are sent to a queue that is held by an
agent program.  Sometimes this is a limitation: we can see cases
where non-agent programs also need to receive events.  Any program
can send an event: this is just a call to the SMT kernel API.

<P>We therefore define the concept of a <EM>floating event
queue</EM>; that is, an event queue that is managed by some
program that is not constructed as an agent:

<PRE>
        Program
           :
         Queue
           :
         Event

Figure: Floating Event Queue
</PRE>

<P>The designer of the application must also find a way to service
the event queue, since the SMT kernel cannot schedule and execute
such a program.

<H3><A NAME="TOC11">Routers</A></H3>

<P>In most cases, one queue is served by one thread.  Thus, when
you send an event to a queue, you are effectively sending it to a
specific thread.

In some cases, it is better to share one queue among several
threads.  Imagine an agent that executes database requests coming
from a set of clients.  A thread takes an event, processes it, and
returns a reply.  Each event is independent, and may take some
time to process.  It makes sense to start several threads, so that
several events can be processed in parallel.  It would be wrong to
allocate one queue per thread, however, for two reasons.  Firstly,
this implies that there are N queues which the clients must know
about.  Secondly, it implies that someone (client or agent)
chooses a queue for each event.  Consequently, events may be
waiting in the queue for one thread while another thread is idle.
By allocating just one queue, shared between all the agent
threads, events are processed at full speed, in arrival order.

<P>An agent is either defined as a <EM>router</EM>, or not.  When
an agent is a router, it is legal to create multiple threads with
the same name.  All threads in a router agent share a single event
queue.

<H3><A NAME="TOC12">Internal and External Events</A></H3>

<P>SMT agents are built as event-driven Libero programs.  We
define two kinds of event: an <EM>internal event</EM> (supplied by
the program itself) and an <EM>external event</EM> (taken from the
event queue).  If we consider a normal Libero program, all events
are internal.  The SMT kernel adds the concept of external
events.

<P>When you design the program dialog, you do not distinguish
internal and external events.  Indeed, a name like "Ok" can be
used for both types of event.

<P>The SMT kernel <EM>delivers</EM> an external event when the
program did not supply an internal event itself.  This occurs at a
state transition, i.e. after executing the action modules for an
event.  When an external event is delivered, it is converted into
an appropriate internal event.

<P>To put it another way: if none of the action modules put a
value into the_next_event, then the SMT kernel will pull an event
from the event queue, translate it into a suitable value, and put
that into the_next_event instead.

<P>The <EM>methods</EM> define the translation from external event
to internal event.  External events that do not match declared
methods are rejected.  This is usually a programming error, so an
error message is sent to the console.

<H3><A NAME="TOC13">Event Management</A></H3>

<P>The SMT kernel provides an level of event management.  Firstly,
it will destroy undelivered events after a specified expiry
period.  Secondly, it will automatically send return events to
acknowledge receipt or non-receipt of an event.  This works as
follows: when you send an event, you may specify reply events for
delivery, rejection, and expiry.

<H3><A NAME="TOC14">Priorities and Scheduling</A></H3>

<P>The SMT kernel has a simple priority and scheduling mechanism.
Agents run with a certain priority level (a number from 1 to 255).
When the SMT kernel delivers events to threads, it schedules the
threads for execution, by placing them in a queue (the <EM>active
list</EM>).  Threads with higher priorities are placed at the
start of the active list.  No account is taken of the time spent
in the active list, so it is quite possible for a set of
high-priority threads to take-up all execution time.  This
normally does not happen, since such threads will eventually wait
for events from somewhere else, so become passive.

<P>Events have a similar priority level, defined by the accepting
program, in the event method.  When the SMT kernel delivers an
event, it chooses the event with the highest priority.  One
example of a high-priority event is <EM>shutdown</EM>, which is
sent to all threads when the SMT kernel receives a 'kill' signal
(i.e. when someone decides to stop the running program).

<P>You can change agent and event priorities on the fly, although
this may get a little complex to manage.  You can also process the
events in an event queue directly, without waiting for the SMT
kernel to deliver each one.

<P>In general we recommend that you leave agents and events with
unspecified priority - i.e. the normal priority level - unless
there are good reasons for doing otherwise.

<H3><A NAME="TOC15">Native Programs Vs. Foreign Programs</A></H3>

<P>A <EM>native program</EM> is designed as a finite-state machine
(FSM) and built using Libero and the smtschm.c schema.  A native
program can be multithreaded.  It is tightly integrated with the
SMT kernel: the kernel supplies events to the program, schedules
and executes threads, etc.

<P>A <EM>native program</EM> is also called a <EM>agent</EM>. The
two terms are equivalent.

<P>A <EM>foreign program</EM> is not based on the smtschm.c
schema.  It is always single threaded, and while it may call SMT
kernel functions, it is not integrated with the kernel.  Typically
a foreign program calls the SMT kernel to send and receive events
and manage floating event queues.

<H3><A NAME="TOC16">The SMT Kernel Meta-State-Machine</A></H3>

<P>We can consider the application (an ensemble of agents, queues,
threads, and events) as a meta-state-machine (i.e. a state machine
that defines a set of state machines).  The application has three
states:
<UL>
<LI><EM>Latent</EM>: we are initialising, but not yet ready to
start executing the threads.
<LI><EM>Active</EM>: we are executing threads.
<LI><EM>Halted</EM>: there are no more active threads, and no
events left to deliver.
</UL>

<P>We do not usually define this as a Libero dialog, though it is
possible to do so.  What we must do is to write a foreign program,
a <EM>stub</EM>, that implements the application meta-state-
machine.  This is the stub for an Internet ECHO daemon, showing
the three states:

<PRE>
#include "sfl.h"                   /*  SFL library header file  */
#include "smtlib.h"                /*  SMT kernel functions     */

int main (int argc, char *argv [])
{
    /*  Application is latent - initialise it                   */
    <A href="smtdoc.htm#smt_init">smt init</A> ();                   /*  Initialise SMT kernel    */
    <A href="smtdoc.htm#smtecho_init">smtecho init</A> (NULL);           /*  Initialise ECHO agent    */

    /*  Application is active - execute it                      */
    <A href="smtdoc.htm#smt_exec_full">smt exec full</A> ();              /*  Run until completed      */

    /*  Application is halted - terminate it                    */
    <A href="smtdoc.htm#smt_term">smt term</A> ();                   /*  Shut-down SMT kernel     */
    return (0);
}
</PRE>

<P>This main code is the glue that joins the various pieces of the
application.

<H2><A NAME="TOC17">Using The SMT Kernel API</A></H2>

<P>The SMT kernel API is aimed mainly at native programs.
However, you can also use the event-passing facilities in foreign
programs.  This can be necessary when interfacing SMT applications
to other event-based systems.

<H3><A NAME="TOC18">SMT Kernel Functions</A></H3>

<P>This is the complete set of functions supported by the SMT
kernel:
<DL>
<DT><A href="smtdoc.htm#smt_init">smt init</A>()</DT>
<DD>Initialise the SMT kernel.</DD>
<DT><A href="smtdoc.htm#smt_term">smt term</A>()</DT>
<DD>Shut-down the SMT kernel.</DD>
<DT><A href="smtdoc.htm#smt_exec_full">smt exec full</A>()</DT>
<DD>Execute the SMT application until halted.</DD>
<DT><A href="smtdoc.htm#smt_exec_step">smt exec step</A>()</DT>
<DD>Execute just next scheduled thread.</DD>
<DT><A href="smtdoc.htm#smt_active">smt active</A>()</DT>
<DD>Check if application has halted.</DD>
<DT><A href="smtdoc.htm#smt_set_console">smt set console</A>()</DT>
<DD>Specify an agent to act as console.</DD>
<DT><A href="smtdoc.htm#smt_set_timer">smt set timer</A>()</DT>
<DD>Specify an agent to act as timer.</DD>
<DT><A href="smtdoc.htm#smt_atexit">smt atexit</A>()</DT>
<DD>Define a termination function.</DD>
<DT><A href="smtdoc.htm#smt_shutdown">smt shutdown</A>()</DT>
<DD>Halt the application prematurely.</DD>
<DT><A href="smtdoc.htm#agent_declare">agent declare</A>()</DT>
<DD>Define a new agent.</DD>
<DT><A href="smtdoc.htm#agent_lookup">agent lookup</A>()</DT>
<DD>Check if a specific agent is defined.</DD>
<DT><A href="smtdoc.htm#agent_destroy">agent destroy</A>()</DT>
<DD>Remove an agent from the SMT kernel tables.</DD>
<DT><A href="smtdoc.htm#method_declare">method declare</A>()</DT>
<DD>Define a method for an agent.</DD>
<DT><A href="smtdoc.htm#method_lookup">method lookup</A>()</DT>
<DD>Check if a specific method is defined.</DD>
<DT><A href="smtdoc.htm#method_destroy">method destroy</A>()</DT>
<DD>Remove a method from the SMT kernel tables.</DD>
<DT><A href="smtdoc.htm#queue_create">queue create</A>()</DT>
<DD>Define an event queue for an agent, or a floating queue.</DD>
<DT><A href="smtdoc.htm#queue_lookup">queue lookup</A>()</DT>
<DD>Check if an event specific queue is defined.</DD>
<DT><A href="smtdoc.htm#queue_destroy">queue destroy</A>()</DT>
<DD>Remove an event queue from the SMT kernel tables.</DD>
<DT><A href="smtdoc.htm#queue_flush">queue flush</A>()</DT>
<DD>Expire out-of-date events in the event queue.</DD>
<DT><A href="smtdoc.htm#event_send">event send</A>()</DT>
<DD>Send an event to some event queue.</DD>
<DT><A href="smtdoc.htm#event_accept">event accept</A>()</DT>
<DD>Accept the next event from an event queue.</DD>
<DT><A href="smtdoc.htm#event_reject">event reject</A>()</DT>
<DD>Reject the next event from an event queue.</DD>
<DT><A href="smtdoc.htm#event_expire">event expire</A>()</DT>
<DD>Expire the next event from an event queue.</DD>
<DT><A href="smtdoc.htm#event_discard">event discard</A>()</DT>
<DD>Discard the next event from an event queue.</DD>
<DT><A href="smtdoc.htm#event_iterate">event iterate</A>()</DT>
<DD>Find the next event in an event queue.</DD>
<DT><A href="smtdoc.htm#event_destroy">event destroy</A>()</DT>
<DD>Destroy a specific event.</DD>
<DT><A href="smtdoc.htm#event_wait">event wait</A>()</DT>
<DD>Wait explicitly for an external event.</DD>
<DT><A href="smtdoc.htm#thread_create">thread create</A>()</DT>
<DD>Define a thread for an agent, maybe create a queue.</DD>
<DT><A href="smtdoc.htm#thread_lookup">thread lookup</A>()</DT>
<DD>Check if a specific thread is defined.</DD>
<DT><A href="smtdoc.htm#thread_destroy">thread destroy</A>()</DT>
<DD>Remove a thread from the SMT kernel tables.</DD>
<DT><A href="smtdoc.htm#semaph_create">semaph create</A>()</DT>
<DD>Create a new semaphore.</DD>
<DT><A href="smtdoc.htm#semaph_lookup">semaph lookup</A>()</DT>
<DD>Check if a specific semaphore is defined.</DD>
<DT><A href="smtdoc.htm#semaph_destroy">semaph destroy</A>()</DT>
<DD>Remove a semaphore from the SMT kernel tables.</DD>
<DT><A href="smtdoc.htm#semaph_wait">semaph wait</A>()</DT>
<DD>When the semaphore value is &gt; 0, decrement it.</DD>
<DT><A href="smtdoc.htm#semaph_signal">semaph signal</A>()</DT>
<DD>Add 1 to the semaphore value.</DD>
<DT><A href="smtdoc.htm#lazy_creat">lazy creat</A>()</DT>
<DD>Create a file, without blocking.</DD>
<DT><A href="smtdoc.htm#lazy_open">lazy open</A>()</DT>
<DD>Open a file, without blocking.</DD>
<DT><A href="smtdoc.htm#lazy_read">lazy read</A>()</DT>
<DD>Read from a file, without blocking.</DD>
<DT><A href="smtdoc.htm#lazy_write">lazy write</A>()</DT>
<DD>Write to a file, without blocking.</DD>
<DT><A href="smtdoc.htm#lazy_close">lazy close</A>()</DT>
<DD>Close a file, without blocking.</DD>
<DT><A href="smtdoc.htm#senderr">senderr</A>()</DT>
<DD>Send the current strerror (errno) to some queue.</DD>
<DT><A href="smtdoc.htm#sendfmt">sendfmt</A>()</DT>
<DD>Format a text using printf conventions and send to some
queue.</DD>
<DT><A href="smtdoc.htm#raise_exception">raise exception</A>()</DT>
<DD>Raise an exception (for dialog programs only).</DD>
<DT><A href="smtdoc.htm#recycle_module">recycle module</A>()</DT>
<DD>Repeat execution of the current dialog module.</DD>
</DL>

<P>The SMT kernel API works with a number of objects - agents,
threads, queues - which are defined as C structures.  The fields
in these structures are the properties of the object.  The SMT
objects contain <EM>private</EM> fields, which you should never
change or refer to, and <EM>public</EM> fields, which you are free
to change and use.  We do not discuss the private fields, except
to note that these contain information that is internal to the SMT
kernel, or reflect particular implementations that may change.

<P>These are the SMT objects and their public fields:

<PRE>
AGENT                      /*  Agent descriptor                 */
    AGENT  *next, *prev    /*    Doubly-linked list             */
    NODE    methods        /*    Methods accepted by agent      */
    NODE    queues         /*    Queues defined for agent       */
    char   *name           /*    Agent's name                   */
    Bool    router         /*    Default = FALSE                */
    int     priority       /*    Default = SMT_PRIORITY_NORMAL  */
    long    max_threads    /*    Default = 0 (no limit)         */
    long    cur_threads    /*    Current number of threads      */
    long    top_threads    /*    Max. number threads we had     */
    long    thread_tally   /*    How many threads created       */
    long    switch_tally   /*    How many context switches      */
</PRE>

<P>An agent defines one program written using the Libero SMT
schema.  When the generated code initialises, it automatically
creates an agent object.  You may change the router, priority, and
max_threads fields, but not the other fields.

<PRE>
METHOD                     /*  Method descriptor                */
    METHOD *next, *prev    /*    Doubly-linked list             */
    AGENT  *agent          /*    Parent agent descriptor        */
    char   *name           /*    Name of method                 */
    int     priority       /*    Default = SMT_PRIORITY_NORMAL  */
    int     event_number   /*    Internal event number          */
</PRE>

<P>The start-up code for an agent (in Initialise-The-Program)
creates a method for each external event it wants to handle.  You
may change the priority and event_number fields, but not the other
fields.

<PRE>
THREAD                     /*  Thread descriptor                */
    THREAD  *next, *prev   /*    Doubly-linked list             */
    QUEUE   *queue         /*    Parent queue descriptor        */
    long     thread_id     /*    Thread identifier number       */
    char    *name          /*    Name of thread                 */
    Bool     animate       /*    Animate this thread            */
    void    *tcb           /*    Thread context block (TCB)     */
    EVENT   *event         /*    Last-received event            */
</PRE>

<P>Any part of the application can create a thread in an agent, if
it knows the name of the agent.  You may change the animate field,
but not the other fields.

<PRE>
QUEUE                      /*  Event queue descriptor           */
    QUEUE  *next, *prev    /*    Doubly-linked list             */
    AGENT  *agent          /*    Parent agent descriptor        */
    NODE    events         /*    Events in queue                */
    NODE    threads        /*    Threads for queue              */
    QID     qid            /*    Queue ID descriptor            */
    int     max_events     /*    Maximum allowed events         */
    int     cur_events     /*    Current number of events       */
</PRE>

<P>The SMT kernel automatically creates event queues as needed.
Generally it will create one event queue per thread.  When an
agent is defined as a router, however, it only creates an event
queue for the first thread.  You can also create floating event
queues.  You may change the max_events fields, but not the other
fields.  Note that each queue has a unique QID; this is the
identifier for the queue, and the information you need to send an
event to a queue.

<PRE>
EVENT                      /*  Event in queue                   */
    EVENT  *next, *prev    /*    Doubly-linked list             */
    QUEUE  *queue          /*    Parent queue descriptor        */
    QID     sender         /*    Replies come back here         */
    char   *name           /*    Name of event                  */
    size_t  body_size      /*    Size of event body in bytes    */
    char   *body           /*    Event body                     */
    char   *accept_event   /*    Reply if we accept event       */
    char   *reject_event   /*    Reply if we reject event       */
    char   *expire_event   /*    Reply if we expire event       */
    time_t  timeout        /*    Expires at this time (or 0)    */
</PRE>

<P>Any part of the application can send an event to an event queue
using the event_send() function.  The queue may be served by a
thread, or not (if it is a floating event queue).  You should not
change any of the fields in the event object: the sender, body,
and body_size fields are generally interesting.

<PRE>
SEMAPH                     /*  Semaphore definition             */
    SEMAPH  *next, *prev;  /*    Doubly-linked list             */
    char    *name;         /*    Name of semaphore              */
</PRE>

<P>Semaphores are for synchronising agents, for instance for
exclusive access to some resource.  We implement general
semaphores, i.e. they can take any value of 0 or greater (the
value is defined as an integer).

<H3><A NAME="TOC19">Initialisation and Termination</A></H3>

<P>An SMT application must explicitly initialise and shut-down the
SMT kernel.  This lets the kernel create global objects (such as
the symbol table) and then destroy them when finished.

<P>The <A href="smtdoc.htm#smt_init">smt init</A>() function initialises the SMT kernel.  The
<A href="smtdoc.htm#smt_term">smt term</A>() function shuts-down the SMT kernel.  These are
generally the first and last SMT functions that the application
calls.  Usually, we'll put these calls in the stub (main)
program.

<P>Any part of the application can call <A href="smtdoc.htm#smt_atexit">smt atexit</A>() to
register a shut-down function; these shut-down functions are
called by <A href="smtdoc.htm#smt_term">smt term</A>(), in the order that you declare them.

<H3><A NAME="TOC20">Creating A Thread</A></H3>

<P>Any program can create a thread in any agent in the application
using the thread_create() function.  To create a thread you must
know the name of the agent and the name of the thread you want to
create.

<P>A thread's name is local within the agent, and lets an outside
program look-up the event queue for that thread.  There are
various ways to name threads.  In single-threaded agents, it is
useful to leave the thread name empty (specified as an empty
string - "").  In multithreaded agents, the thread name can
correspond to some resource name.  For instance, in the echo
agent, the thread uses the connection socket number as its name.
In a <EM>router</EM> agent, several threads can have the same
name; since the threads in such an agent share the same event
queue, this allows a program to unambigouously find the event
queue from the thread name.

<P>This is how a single-threaded agent (e.g. the operator console)
creates a thread:

<PRE>
    /*  Create initial, unnamed thread                          */
    <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "");
</PRE>

<P>This is how the <A href="smtdoc.htm#SMTECHO">echo agent</A> creates a thread to
handle a new connection (tcb-&gt; handle contains the handle of
the echo master socket):

<PRE>
    SOCKET
        slave_socket;           /*  Connected socket            */
    static char
        thread_name [12];       /*  Socket number as string     */

    slave_socket = accept_socket (tcb-&gt; handle);
    if (slave_socket != INVALID_SOCKET)
      {
        sprintf (thread_name, "%d", slave_socket);
        <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, thread_name);
      }
</PRE>

<H3><A NAME="TOC21">Sending and Receiving Events</A></H3>

<P>These are the API functions that you can use to send an event:
<DL>
<DT><A href="smtdoc.htm#event_send">event send</A>()</DT>
<DD>Send an event to some event queue.</DD>
<DT><A href="smtdoc.htm#senderr">senderr</A>()</DT>
<DD>Send the current strerror (errno) to some queue.</DD>
<DT><A href="smtdoc.htm#sendfmt">sendfmt</A>()</DT>
<DD>Format a text using printf conventions and send to some
queue.</DD>
</DL>

<P>In all cases, the target queue is specified as a <EM>QID</EM>.
The QID is a location-independent queue identifier that the SMT
kernel creates for each queue.  We use a QID instead of the
address of the queue object so that events can be sent between
processes running in different address spaces.  (Although this is
not yet implemented.)

<P>When you send an event, you specify an event name.  An agent
program must have declared a method for each event it can accept.
There is no such restriction for other programs that manage event
queues themselves.

<P>An event has a body, which is a block of text or binary data
that is copied to the receiving event queue.  You should always
ensure that event bodies are portable, since the receiving event
queue could in principle be on a different system.  Furthermore,
an event body cannot include the address of an object or variable:
events can cross address spaces (i.e. be sent to other processes)
so that such addresses are not meaningful.

<H3><A NAME="TOC22">Sending An Initial Event To A Thread</A></H3>

<P>You can send an event to a thread as soon as it has been
created.  This can be useful if you need to pass arguments to a
child thread.  The event will be delivered <EM>after</EM> the
initialise_the_thread module, if you do not specify a value for
<TT>the_next_event</TT>.  For an example, see the echo agent
<A href="smtdoc.htm#SMTECHO">SMTECHO</A>.

<H3><A NAME="TOC23">Event Lifespan and Acknowledgment</A></H3>

<P>The <A href="smtdoc.htm#event_send">event send</A>() call lets a program specify these optional
arguments:
<UL>
<LI>Reply queue - usually the queue for the thread or program that
sent the event.
<LI>Accept event - an event that is returned when the event has
been sucessfully delivered (though not necessarily processed).  If
left unspecified, the caller will not be informed when the event
is delivered.
<LI>Reject event - an event that is returned if the event is
rejected by the recipient.  (Typically it is not accepted by the
thread in its current state.)  If left unspecified, the caller
will not be informed when the event is rejected.
<LI>Timeout - a timeout in seconds after which the event will
expire.
<LI>Expire event - an event that is returned when the event has
expired dues to a timeout.  If left unspecified, the caller will
not be informed when the event expires.
</UL>

<P>When a program wants to inspect the events in a queue, it uses
<A href="smtdoc.htm#event_iterate">event iterate</A>(), which walks through the queue, event by
event. To take an event off the queue, a program calls
<A href="smtdoc.htm#event_accept">event accept</A>(). This automatically sends an accept event, if
specified.
If queue is empty it simply returns with an 'not found' feedback.
Some programs implement event priorities by combining
<A href="smtdoc.htm#event_iterate">event iterate</A>() with <A href="smtdoc.htm#event_accept">event accept</A>().  A program may
manipulate several event queues.

<P>To remove an event without using it, a program calls
<A href="smtdoc.htm#event_destroy">event destroy</A>().  The <A href="smtdoc.htm#event_destroy">event destroy</A>() call automatically
sends a reject event, if specified.

<P>The SMT kernel handles event expiry automatically for native
programs.  Programs that handle floating event queues must expire
old events explicitly by calling <A href="smtdoc.htm#queue_flush">queue flush</A>() before they
start to process waiting events.

<H3><A NAME="TOC24">Using Priorities</A></H3>

<P>The SMT kernel provides support for event priorities and for
thread priorities.  These work as follows:
<UL>
<LI>When several events are waiting to be delivered to an agent,
the event with the highest priority is always delivered first.
When several events have the same priority, the oldest event is
delivered first.
<LI>When a thread is scheduled for execution it is always
scheduled before the first thread with a lower priority.
</UL>

<P>In practice we use priorities rarely, and for specific cases
only.  In the current version of the SMT kernel we use a high
priority for shutdown events, and a low priority for the socket
agent.  All other events and threads have normal (equal)
priority.


<H2><A NAME="TOC25">Writing A Native SMT Program</A></H2>

<P>A native program is a <EM>agent</EM>.  To build an agent you:
<UL>
<LI>Design a dialog using Libero, and base the dialog on the
smtschm.c schema (specify -schema=smtschm.c).
<LI>Generate a skeleton program.
<LI>Modify the program and dialog, regenerate, compile, and link
the application, and repeat until satisfied.
</UL>

<P>When you design an agent you must decide whether the it is
single-threaded or multithreaded.  What's the difference?
<UL>
<LI>A single-threaded agent handles just one logical thread; a
multithreaded agent handles multiple logical threads in
parallel.
<LI>A single-threaded agent manages one event queue; a
multithreaded agent manages (usually) several event queues.
<LI>A multithreaded agent is usually 'connection oriented' while
a single-threaded agent is usually 'service oriented'.
</UL>

<P>By convention, a single-threaded agent creates an unnamed
thread when it initialises.  A multithreaded agent, by contrast,
typically create a new thread for each new connection, and uses a
different name for each thread.

<P>An example of a single-threaded agent is the operator console.
This is a program that accepts error messages or warnings from
other parts of the application, then does something useful with
them.  (The current implementation writes them to stderr.)  The
operator console has no need for multiple threads.

<P>An example of a multithreaded agent is the logging agent.  This
is a program that manages log files on behalf of other application
programs.  It does this at a low priority, and without blocking,
so that log file data is written without disturbing ongoing work.
The logging agent can write to several log files in parallel: it
does this by having one thread for each log file.

<P>To specify that an agent is single-threaded, define
SINGLE_THREADED as TRUE near the start of the program.  For
instance, this code comes from the SMTOPER agent:

<PRE>
/*- Definitions ------------------------------------------------*/

#define AGENT_NAME      SMT_OPERATOR  /*  Our public name       */
#define SINGLE_THREADED TRUE          /*  Single-threaded agent */
</PRE>

<H3><A NAME="TOC26">Initialising An agent</A></H3>

<P>An agent program must be 'initialised' before it can do any
useful work.  For instance, to initialise the logging agent, the
application must call the function <A href="smtdoc.htm#smtlog_init">smtlog init</A>().  Generally,
agents are initialised by the stub program, or by other agents.
We generally recommend that an agent always try to initialise
every agent it requires.  It is safe to call initialisation
function for an agent several times; only the first call has any
effect.

<P>The initialisation function is the only public function for a
agent.  Once an agent is initialised, it communicates with other
programs only via events.

<P>An agent program is based on a Libero dialog, and is 'driven'
by a chunk of code generated by Libero.  This code (defined as an
#include file) handles the initialisation of the agent.  The code
looks something like this (we explain each part):

<PRE>
if (<A href="smtdoc.htm#agent_lookup">agent lookup</A> (AGENT_NAME))
    return (0);                 /*  Agent already declared     */
</PRE>

<P>The <A href="smtdoc.htm#agent_lookup">agent lookup</A>() function returns NULL if an agent object
with the specified name already exists.  Otherwise it returns a
pointer to the agent object.  Here we check that the agent has
not already been declared.  The generated code assumes that
AGENT_NAME has been defined to hold the name of the agent.
AGENT_NAME can be a variable or a pre-processor macro (the
generated skeleton program defines it as a macro).

<PRE>
if ((agent = <A href="smtdoc.htm#agent_declare">agent declare</A> (AGENT_NAME)) == NULL)
    return (-1);                /*  Could not declare agent    */
</PRE>

<P>The <A href="smtdoc.htm#agent_declare">agent declare</A>() function returns a pointer to the
newly-created agent object.  If there was an error (e.g. not
enough memory), it returns NULL.

<PRE>
#if (defined (SINGLE_THREADED))
agent-&gt; tcb_size    = 0;    /*  No context block            */
agent-&gt; max_threads = 1;    /*    and max. 1 thread         */
#else
agent-&gt; tcb_size    = sizeof (TCB);
#endif
</PRE>

<P>Once the agent has been created, the generated code sets the
thread context block (TCB) size depending on whether the agent is
single threaded or multithreaded.  A single-threaded agent does
not need TCBs, so the size is zero.  The code assumes that
SINGLE_THREADED has been defined as a macro if required.  The
generated code then sets a variety of fields in the agent block.
This allows the SMT kernel to 'drive' the agent program
correctly.

<P>This is how a typical multithreaded agent program initialises
(this code is taken from smtlog.c):

<PRE>
#define AGENT_NAME  SMT_LOGGING    /*  Our public name         */
</PRE>

<P>The SMT_LOGGING symbol is defined in the standard SMT header
file, smtlib.h, since this agent is part of the standard package.
For your own agents you would define AGENT_NAME as a string
literal.  Note that agent names must be unique within the
application.

<PRE>
int smtlog_init (void)
{
    AGENT   *agent;             /*  Handle for our agent        */
    THREAD  *thread;            /*  Handle to console thread    */
#   include "smtlog.i"          /*  Include dialog interpreter  */
</PRE>

<P>The initialisation code in smtlog.i assumes that a variable
'agent' is defined.  Then, you can refer to the agent in
following code using this 'handle'.  The first thing we do is to
declare each method:

<PRE>
/*                           Method     Event value  Priority  */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN", shutdown_event,
                                             SMT_PRIORITY_MAX);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "OPEN",     open_event,         0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "PUT",      put_event,          0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "CLOSE",    close_event,        0);
</PRE>

<P>Methods names are not case-sensitive, but by convention we
specify them in uppercase.  Every agent must support the SHUTDOWN
method; this is sent to each agent when the SMT kernel terminates
(for instance when interrupted).  SHUTDOWN gets a high priority,
so that an agent will handle shutdown events before any other
waiting events.  The other events get a normal priority (0 means
'default').

<P>You can define several methods for the same event.  The SMT
kernel uses the set of methods to translate an incoming external
event into an internal dialog event.

<PRE>
    /*  Ensure that operator console is running, else start it  */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        console = thread-&gt; queue-&gt; qid;
    else
        return (-1);
</PRE>

<P>This agent sends error messages to the operator console agent,
which is generally a good idea.  It initialises the agent (with
no effect if the agent is already initialised) and then gets the
console queue id, so it can send events to the operator console.
Note how we do a <A href="smtdoc.htm#thread_lookup">thread lookup</A>() with an empty thread name.
The operator console is single threaded, and that single thread
has no name.

<PRE>
    /*  Signal okay to caller that we initialised okay          */
    return (0);
}
</PRE>

<P>Finally, if everything went as expected, we return 0 to signal
that to the calling program.  This is a convention, although you
can write the initialisation function any way you like, accepting
any arguments and returning any value that is appropriate.

<H3><A NAME="TOC27">The Thread Context Block</A></H3>

<P>Threads can share data: any global data in the agent program
is de-facto shared by all threads.  Since threads also need
'private' data, each thread owns a block of memory called the
Thread Context Block, or TCB.  The SMT kernel allocates such a
block when a thread is created.

<P>The TCB is a structure that contains arbitrary fields.  You
define this structure at the start of your program.  All code
modules in the program receive a pointer to this structure: they
use the pointer to reference private data.  For instance, this is
how the smtlog.c agent declares its TCB:

<PRE>
typedef struct                  /*  Thread context block:       */
{
    int handle;                 /*    Handle for i/o            */
} TCB;
</PRE>

This is how the smtlog.c agent opens a file:

<PRE>
/*******************   OPEN THREAD LOGFILE   ********************/

MODULE open_thread_logfile (THREAD *thread)
{
    char
        *logfile_name;

    tcb = thread-&gt; tcb;         /*  Point to thread's context   */

    /*  Event body or thread name supplies name for log file    */
    logfile_name = (strused (thread-&gt; event-&gt; body)?
                    thread-&gt; event-&gt; body:
                    thread-&gt; name);
    tcb-&gt; handle = <A href="smtdoc.htm#lazy_creat">lazy creat</A> (logfile_name, S_IREAD | S_IWRITE);
    if (io_completed)
      {
        if (tcb-&gt; handle &lt; 0)   /*  If open failed, send error  */
          {                     /*    to console, and terminate */
            <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "ERROR",
                     "Could not open %s for output",
                      logfile_name);
            <A href="smtdoc.htm#senderr">senderr</A> (&console);
            <A href="smtdoc.htm#raise_exception">raise exception</A> (exception_event);
          }
      }
}
</PRE>

<H3><A NAME="TOC28">Choosing Event Names</A></H3>

<P>We generally use the same name for the method as for the event.
E.g. CLOSE and close_event.  This is not obligatory, and in some
cases not appropriate, but it does make the program easier to
understand when dialog event names correspond to methods.

<H3><A NAME="TOC29">Mechanics Of Event Delivery</A></H3>

<P>The agent kernel delivers events to threads when required.
This happens at a precise moment: when the thread moves to a new
dialog state -- after executing the action module list -- and no
internal event was provided.

<P>When a thread moves into a state, the set of possible events is
those events defined in that state, plus the events defined in the
Defaults state, if any.

<P>The SMT kernel takes the following event (or the event with the
highest priority) and tries to match it to a method name.  If the
event does not match a method, the event is rejected.  Otherwise
it is accepted and translated into an internal event number.  If
the internal event is illegal at that moment in the dialog, this
causes a fatal dialog error (the thread rejects the event).

<H3><A NAME="TOC30">Waiting For An External Event</A></H3>

<P>Normally the SMT kernel delivers an external event when the
dialog moves to a new state, and no event was specified.  In some
cases this can make a dialog rather large, since you need to break
each step up into states.  The <A href="smtdoc.htm#event_wait">event wait</A>() function causes
the dialog to halt until an event can be taken from the queue.
When several threads are executable, this function also switches
execution to the next thread.

<P>The <A href="smtdoc.htm#event_wait">event wait</A>() call sets the variable
"the_external_event".  This should be the last statement in a
dialog module.  When used in the last module in a list, it has
strictly no effect.

<H3><A NAME="TOC31">Sending Structured Event Data</A></H3>

<P>Events can optionally have a body to carry additional
information.  When you send textual data - for instance a string -
the event body can be transferred between programs without any
type of conversion.  (We ignore problems of character-set
conversion at present.)

<P>When you need to send several items in one event body, we speak
of sending <EM>structured data</EM>.  Structured data consists of
a mixture of data items of these types:
<UL>
<LI>Single bytes
<LI>Characters
<LI>Double-bytes
<LI>Quad-bytes
<LI>Booleans
<LI>Null-terminated strings
<LI>Blocks of binary data
</UL>

<P>An example of events with structured data are those accepted by
the socket i/o agent <A href="smtdoc.htm#SMTSOCK">SMTSOCK</A>.

<P>In C, we can group the data items in a structure, hence the
term.  We cannot, however, simply copy the structure into the
message and send that.  We cannot copy the address of the
structure.  Both these methods will work today, but an event may
(in the future) be sent to an agent in a different process,
perhaps running on a different machine.
<UL>
<LI>The agent may run in a different address space, so passing
addresses is definitely not a good idea.
<LI>Structures can contain empty space (padding) that depends on
the compiler used, the compiler options, and the machine word
size.  So, if you pass a structure as-is, the data may not map
correctly to the receiving program's structure.
<LI>Different systems use different ways of ordering the bytes in
a multi-byte integer.  One often hears the terms 'little-endian'
and 'big-endian'; these are just the two main varieties.
</UL>

<P>Our solution is to take each data field in turn, and pack the
structure into a machine-independent stream.  We transmit this
stream, then do the reverse unpacking in the target program.

<P>To do the conversion we use the SFL functions exdr_read() and
exdr_write().

<P>This is more work than just sending the complete structure, but
is the only way to ensure that data can safely be sent between two
programs that may be running on separate systems.

<H3><A NAME="TOC32">Sending Events Within An Agent</A></H3>

<P>Within one agent, you do not need to use the EXDR functions.
It is quite acceptable to pass data in a structure.  To do this,
<UL>
<LI>Define a structure for each event you want to send;
<LI>To send an event, fill-in the structure fields and send the
structure using the event_send function;
<LI>Access the individual fields using a type cast as follows:
<PRE>(SOMESTRUCT *) thread-> event-> body-> some_field</PRE>
</UL>

<H3><A NAME="TOC33">Ignoring External Events</A></H3>

<P>In some cases, you may want to ignore reply events sent by an
agent.  This can be useful to simplify a dialog.  This is how we
declare a method to ignore some specific event:

<PRE>
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOME_EVENT", SMT_NULL_EVENT, 0);
</PRE>

<H3><A NAME="TOC34">Non-Blocking File Access</A></H3>

<P>The SMT kernel provides a minimum file access layer that is
safe to use in multithreaded programs.  To understand what this
means, first understand what is 'unsafe'.

<P>On some systems, like UNIX and Digital VMS, file access may
need resources that are not always available - like memory for
buffers.  If you ask to read some data from a file, and there is a
problem, the operating system may loop a few times - waiting and
then trying again - before finally returning to the calling
program.  In the meantime your program and all threads are
blocked.

<P>The general solution is to request <EM>non-blocking file
access</EM>.  Then, in the case of a resource problem, the
operating will not loop, but will return at once with an error
code that means 'try again'.  The SMT kernel integrates this
solution with its thread management, so that a thread waiting for
file access will loop slowly, allowing other threads to continue
to run.

<P>To make this work, you should not call the open(), creat(),
read(), or write() functions directly in your program.  Instead,
call the SMT kernel functions <A href="smtdoc.htm#lazy_open">lazy open</A>(), <A href="smtdoc.htm#lazy_creat">lazy creat</A>(),
<A href="smtdoc.htm#lazy_read">lazy read</A>(), <A href="smtdoc.htm#lazy_write">lazy write</A>(), and <A href="smtdoc.htm#lazy_close">lazy close</A>().
Furthermore, construct your code like this:

<PRE>
rc = <A href="smtdoc.htm#lazy_write">lazy write</A> (tcb-> handle, formatted, fmtsize);
if (io_completed && rc < 0)     /*  If write failed send error  */
  {                             /*    to console and terminate  */
    <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "ERROR",
             "Could not write to %s", thread-> name);
    <A href="smtdoc.htm#senderr">senderr</A> (&console);
    <A href="smtdoc.htm#raise_exception">raise exception</A> (exception_event);
  }
</PRE>

<P>If <TT>io_completed</TT> is FALSE, then the code module should
do no further work.  In this case the SMT kernel automatically re-
executes the <EM>entire</EM> code module.

<P>This is simple and sufficient for sequential file access.  If
you need heavy database access, where one SELECT statement may
take a long time to complete, you'll find that your program
responds slowly.  A better architecture in such cases is to handle
database requests in a separate process, which talks to your
application program using sockets.  The requests will take the
same time to complete, but in the meantime other threads - e.g.
handling new connections - can run normally.

<P>While we generally recommend you use the non-blocking i/o
functions, there are instances where this is not really necessary.
Most obviously, when an application is initialising (e.g. reading
configuration files) or terminating (dumping data to a log file),
there is no need to avoid blocking i/o.  In such cases, you can
access sequential files directly.

<H3><A NAME="TOC35">Real-time Programming</A></H3>

<P>When you call a function like <A href="smtdoc.htm#lazy_read">lazy read</A>() and it detects a
'busy' condition, it sets <TT>io_completed</TT> to FALSE, and
automatically re-executes the current code module.  You may want
to manage this yourself, however.  It can also be useful to have a
similar looping when you access a socket and receive the EAGAIN
error code.

<P>The <A href="smtdoc.htm#recycle_module">recycle module</A>() function lets you control this looping
explicitly.  For example, we can decide to abort a file access
after more than RETRY_MAX retries:

<PRE>
typedef struct                  /*  Thread context block:       */
{
    int handle;                 /*    Handle for i/o            */
    int retries;                /*    Number of retries so far  */
} TCB;
</PRE>

Let's assume that 'retries' has been set to zero, either during
thread initialisation (okay), or by a specific dialog module
(better).  We can then try to open a file like this, calling
<A href="smtdoc.htm#recycle_module">recycle module</A>() with a FALSE argument to prevent looping when
we have retried too often:

<PRE>
/********************   OPEN THREAD LOGFILE   *******************/

MODULE open_thread_logfile (THREAD *thread)
{
    tcb = thread-&gt; tcb;         /*  Point to thread's context   */

    /*  Our thread's name is the name for the log file          */
    tcb-&gt; handle = <A href="smtdoc.htm#lazy_creat">lazy creat</A>
                      (thread-&gt; name, S_IREAD | S_IWRITE);
    if (io_completed)
      {
        /*  If open failed, send error to console, and end      */
        if (tcb-&gt; handle &lt; 0)
          {
            <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "ERROR",
                     "Could not open %s for output", thread-&gt; name);
            <A href="smtdoc.htm#senderr">senderr</A> (&console);
            <A href="smtdoc.htm#raise_exception">raise exception</A> (exception_event);
          }
      }
    else
      {
        if (++tcb-> retries == RETRY_MAX)
          {
            <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "ERROR",
                     "Could not open %s for output", thread-&gt; name);
            <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "ERROR", "Too many retries.")
            <A href="smtdoc.htm#raise_exception">raise exception</A> (exception_event);
            <A href="smtdoc.htm#recycle_module">recycle module</A> (FALSE);
          }
      }
}
</PRE>

<H3><A NAME="TOC36">Using Semaphores</A></H3>

<P>A <EM>semaphore</EM> is an object that you can use to
synchronise threads, lock resources, etc.  Semaphores are widely-
used in multithreaded and parallel computing, and the SMT kernel
implements semaphores in a conventional manner.  Semaphores have
these characteristics:
<UL>
<LI>Any program can create or destroy semaphores, at any time,
using <A href="smtdoc.htm#semaph_create">semaph create</A>() and <A href="smtdoc.htm#semaph_destroy">semaph destroy</A>().
<LI>Semaphores are identified by name and can be located using
<A href="smtdoc.htm#semaph_lookup">semaph lookup</A>().
<LI>Any resource - such as a file - can be <EM>protected</EM> by a
semaphore through convention.  All parties that access the
resource agree to use a single semaphore to lock access to the
resource.
<LI>Semaphores have a numeric value that is 0 or greater.
<LI>The initial value for a semaphore indicates the number of
parties that can access the semaphore's resource at once.
'Normal' <EM>binary semaphores</EM> have an initial value of 1.
The SMT kernel permits <EM>general semaphores</EM> with an initial
value of 1 or greater.
<LI>A thread that wants to access a semaphore's resource uses
<A href="smtdoc.htm#semaph_wait">semaph wait</A>() to wait until the semaphore is ready, then it
decrements the semaphore's value.
<LI>When a thread has finished using the resource it uses
<A href="smtdoc.htm#semaph_signal">semaph signal</A>() to increment the semaphore's value, so allow
other threads to access the resource.
</UL>

<H3><A NAME="TOC37">Replacing The Standard Agents</A></H3>

<P>In realistic projects you will want to replace the operator
console agent and perhaps the logging agent with your own,
customised versions.  One way to do this is to modify the code of
the programs we supply.  However, this just causes maintenance
problems.  A better way is to use the existing code as a basis for
new agents that use the same agent name (but written as a
different source file).  Initialise the replacement agent from
your main() function.  Then, the standard agent will never be
initialised.  All events normally sent to the standard agent will
be sent to your agent instead.  Do not try to change the form or
meaning of events sent to the standard agents.

<H2><A NAME="TOC38">Using The SMT API In A Foreign Program</A></H2>

<P>In an SMT application there will always be some
<EM>foreign</EM> programs.  Some examples are:
<UL>
<LI>The stub that starts-up the application.
<LI>Programs that interface with non-SMT event-supplying
systems.
</UL>

<P>It may make sense in some applications to write all programs as
foreign.  For instance, you could use the SMT kernel simply to
send events between programs without using the multithreading
facilities.

<H3><A NAME="TOC39">Writing A Stub Program</A></H3>

<P>When you build a new SMT application you must also write a STUB
program (the main() function).  The stub program usually does
this:
<UL>
<LI>It initialises the SMT kernel by calling <A href="smtdoc.htm#smt_init">smt init</A>().
<LI>It initialises each agent that it needs.
<LI>It tells the SMT kernel to execute the application by calling
<A href="smtdoc.htm#smt_exec_full">smt exec full</A>().
<LI>It terminates the SMT kernel by calling <A href="smtdoc.htm#smt_term">smt term</A>().
</UL>

<P>When you compile and link the stub, you create the executable
program for the application.

<H3><A NAME="TOC40">Managing A Floating Event Queue</A></H3>

<P>An interface between a native program (or a thread) and a
foreign program consists of at least an event queue in either
direction.  The SMT kernel automatically handles the event queue
for the native program.  You must handle the other event queue
yourself:

<PRE>
       Foreign                               Native
   .--------------.                     .--------------.
   : event_send() :-----------&gt; ()()()():              |
   :              |()()()() &lt;-----:-----: event_send() |
   `=============="    :          :     `=============="
                       :        normal event queue
                       `----- floating event queue

Figure: Managing a floating event queue
</PRE>

<P>The program that sends an event does not know whether the event
queue is floating or not, although it can find this out if it has
to, by examining the queue object.  The difference between a
floating event queue and a normal event queue is that you must get
events off a floating event queue yourself.  You can use the API
function calls:
<DL>
<DT><A href="smtdoc.htm#event_accept">event accept</A>()</DT>
<DD>Accept the next event from an event queue.</DD>
<DT><A href="smtdoc.htm#event_reject">event reject</A>()</DT>
<DD>Reject the next event from an event queue.</DD>
<DT><A href="smtdoc.htm#event_expire">event expire</A>()</DT>
<DD>Expire the next event from an event queue.</DD>
<DT><A href="smtdoc.htm#event_discard">event discard</A>()</DT>
<DD>Discard the next event from an event queue.</DD>
<DT><A href="smtdoc.htm#event_iterate">event iterate</A>()</DT>
<DD>Find the next event in an event queue.</DD>
<DT><A href="smtdoc.htm#event_destroy">event destroy</A>()</DT>
<DD>Destroy a specific event.</DD>
</DL>

<P>You can use methods if you need to.  This can be a convenient
way of translating event names into internal numbers of some sort.
For instance, if you design the foreign program using the standard
Libero C schema, you can use methods to translate event names into
internal numbers, much as the SMT kernel does for a native
program.  This is (more or less) the SMT kernel code that does
this translation:

<PRE>
    EVENT   *event;             /*  Event information block     */
    EVENT   *deliver_event;     /*  Event to deliver            */
    METHOD  *method;            /*  Method information block    */
    THREAD  *active;            /*  Thread in active list       */
    int     top_priority;       /*  Highest event priority      */
    int     event_number;       /*  Number for event to deliver */

    /*  Get event to deliver - find event with highest priority */
    top_priority  = -1;
    deliver_event = NULL;
    event = queue-&gt; events.next;
    while ((NODE *) event != &queue-&gt; events)
      {
        /*  Lookup method; if method not declared, reject event */
        method = <A href="smtdoc.htm#method_lookup">method lookup</A> (agent, event-&gt; name);
        if (method == NULL)
          {
            /*  Reject this event, but keep place in queue...   */
            <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "ERROR",
                     "Event %s not declared by %s",
                      event-&gt; name, agent-&gt; name);
            event = event-&gt; next;
            <A href="smtdoc.htm#event_reject">event reject</A> (queue, event-&gt; prev);
            continue;           /*  Process this new event      */
          }
        if (method-&gt; priority &gt; top_priority)
          {
            deliver_event = event;
            event_number  = method-&gt; event_number;
            top_priority  = method-&gt; priority;
          }
        event = event-&gt; next;
      }
    if (deliver_event)
      {
        /*  Deliver event, move thread to active queue          */
        thread-&gt; event          = <A href="smtdoc.htm#event_accept">event accept</A> (queue,
                                  deliver_event);
        thread-&gt; the_next_event = event_number;
        thread-&gt; active         = TRUE;
      }
</PRE>

<H3><A NAME="TOC41">Executing The Application</A></H3>

<P>The main() function in an executable is a foreign program.
Since a foreign program is external to the multithreading process
of the SMT kernel, control must pass back and forwards between the
SMT kernel and the foreign program.  Typically this is a loop like
this:
<UL>
<LI>Collect any events and send them to the appropriate event
queues.
<LI>Call the SMT kernel to deliver the events and execute all
active threads.
<LI>Repeat until the application has ended.
</UL>

<P>To do the second step, the foreign program calls
<A href="smtdoc.htm#smt_exec_full">smt exec full</A>().  This function runs all the agent threads
until there are no more events left to deliver, or active
threads.

<P>Sometimes it is better to call <A href="smtdoc.htm#smt_exec_step">smt exec step</A>()
repeatedly. This function delivers events, but only executes the
first active thread.  This function provides a finer-grain
control.  For instance, if the application loops because two
threads send each other events in a never-ending loop (usually a
programming error), the <A href="smtdoc.htm#smt_exec_full">smt exec full</A>() call will never
return, while the <A href="smtdoc.htm#smt_exec_step">smt exec step</A>() call will return each
time that the kernel switches between the threads.

<H2><A NAME="TOC42">Standard SMT Agents</A></H2>

<P>The SMT architecture lets one build an application out of
existing and new agents.  We provide a number of standard agents.
All these agents correctly support the <TT>shutdown</TT> method,
which the SMT kernel broadcasts when it needs to end the
application.

<P>These are the standard SMT agents:
<UL>
<LI>The logging agent <A href="smtdoc.htm#SMTLOG">SMTLOG</A> - writes data to log files.
<LI>The operator console <A href="smtdoc.htm#SMTOPER">SMTOPER</A> - handles error messages
produced by other agents.
<LI>The timer agent <A href="smtdoc.htm#SMTTIME">SMTTIME</A> - generates one-off or repeated
timing events.
<LI>The time-slot agent <A href="smtdoc.htm#SMTSLOT">SMTSLOT</A> - generates events
according to a set of time-slots.
<LI>The socket agent <A href="smtdoc.htm#SMTSOCK">SMTSOCK</A> - handles input and output on
sockets.
<LI>The transfer agent <A href="smtdoc.htm#SMTTRAN">SMTTRAN</A> - handles message and basic
file transfer via TCP sockets.
<LI>The TCP echo agent <A href="smtdoc.htm#SMTECHO">SMTECHO</A> - handles the TCP echo
protocol.
<LI>The HTTP agent <A href="smtdoc.htm#SMTHTTP">SMTHTTP</A> - handles the HTTP server
protocol.
<LI>The simulation agent <A href="smtdoc.htm#SMTSIMU">SMTSIMU</A> - simulates network delays.
</UL>

<P>These agents are in development, or planned:
<UL>
<LI>The FTP agent SMTFTP - handles the FTP protocol.
<LI>The secure socket agent SMTSSL - handles input and output
using the Secure Socket Layer protocol.
<LI>The fileio agent SMTFILE - handles input and output to
sequential files, with caching.
<LI>The robust transfer protocol (RTP) agent SMTRTP - handles
robust data transfer via UDP sockets.
<LI>The zip/unzip agent SMTZIP - handles access to compressed
files using the zip standard.
</UL>

<A NAME="SMTLOG">&nbsp;</A>
<H3><A NAME="TOC43">The Logging Agent - SMTLOG</A></H3>

<P>Creates log files, and writes data to the log files.  Can
handle multiple log files in parallel; each open log file is
managed by one thread.  Sends errors to the operator console
agent.

<P>To use, call <A href="smtdoc.htm#smtlog_init">smtlog init</A>().  This does not create any
threads. Create an unnamed thread using the thread_create()
function.  Send an OPEN or APPEND event to create the log file and
PUT events to write to the log file.  Finally, send a CLOSE event
to close the log file and terminate the log file thread.  SMTLOG
does not reply - errors are sent to the console, not the
requesting program.  It supports these methods:
<UL>
<LI>CYCLE - cycle log file if it already exists.
<LI>OPEN - create new, empty log file.
<LI>APPEND - open log file in append mode.
<LI>PUT - write line of data to log file.
<LI>PLAIN - do not timestamp logged data.
<LI>STAMP - timestamp logged data (default).
<LI>CLOSE - close log file and destroy log file thread.
</UL>

<P>Example of initialising SMTLOG:

<PRE>
/*  Static data                                                 */
static QID
    logq;                       /*  Logging agent event queue   */

    /*  In agent initialisation code                            */
    THREAD  *thread;            /*  Handle to various threads   */
    /*  Ensure that logging agent is running, else start it     */
    <A href="smtdoc.htm#smtlog_init">smtlog init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (SMT_LOGGING, "")) != NULL)
        logq = thread-&gt; queue-&gt; qid;   /*  Get logging queue id */
    else
        return (-1);
</PRE>

<H4>The CYCLE Method</H4>

<P>If the specified log file already exists, renames it to a file
whose name consists of the first letter of the log file name,
followed by the date in 7 positions (YYYYDDD).  If that file
name already exists, generates a unique filename.  Takes the
event body to supply the log file name; if the event body is
empty, uses the thread name instead.  If the log file name is
empty ("") or the 4-letter string "NULL", nothing is done.

<H4>The OPEN Method</H4>

<P>Creates a new, empty log file.  Takes the event body to supply
the log file name; if the event body is empty, uses the thread
name instead.  If the log file name is "" or "NULL", no file is
created, and SMTLOG discards all output.

<H4>The APPEND Method</H4>

<P>Opens an existing log file for additional output.  If the log
file does not already exist, acts like OPEN.  Takes the event body
to supply the log file name; if the event body is empty, uses the
thread name instead.

<H4>The PUT Method</H4>

<P>Takes the event body as a string, prefixes the date and time,
and writes it to the log file.

<H4>The PLAIN Method</H4>

<P>Disables time-stamping of the logged data.  Use this when you
do not want the default SMTLOG time-stamping.

<H4>The STAMP Method</H4>

<P>Enables time-stamping of the logged data.

<H4>The CLOSE Method</H4>

<P>Closes the log file and destroys the thread used to manage it.
You normally send this event when you end your program.

<H4>Example Of Use</H4>

<P>The <A href="smtdoc.htm#SMTECHO">SMTECHO</A> agent shows an example of using the Logging
agent.

<H4>SMTLOG Implementation</H4>

<P>The <A HREF="smtlog.htm">hypertext view</A> of SMTLOG's dialog
and source code may help to understand how SMTLOG works.

<A NAME="SMTOPER">&nbsp;</A>
<H3><A NAME="TOC44">The Operator Console Agent - SMTOPER</A></H3>

<P>Accepts error messages, warnings, and information messages, and
does something useful (but unspecified) with them.  The current
implementation writes all received messages to the standard error
device.

<P>To use SMTOPER, call <A href="smtdoc.htm#smtoper_init">smtoper init</A>().  This creates a single
unnamed thread automatically the first time it is called, and has
no effect thereafter.  You can then send messages to this thread.
SMTOPER does not reply.  It supports these methods:
<UL>
<LI>ERROR - handle serious error message.
<LI>WARNING - handle warning message.
<LI>INFO - handle information message.
<LI>LOG - direct console messages to a log file.
</UL>

<P>Example of initialising SMTOPER:

<PRE>
/*  Static data                                                 */
static QID
    console;                    /*  Operator console queue      */

    /*  In agent initialisation code                            */
    THREAD  *thread;            /*  Handle to console thread    */
    /*  Ensure that operator console is running, else start it  */
    smtoper_init ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        console = thread-&gt; queue-&gt; qid;
    else
        return (-1);
</PRE>

<H4>The ERROR Method</H4>

<P>The event body contains a string.  This string is handled as a
serious error message.  For example:

<PRE>
    <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "ERROR", "Could not open %s", filename);
    <A href="smtdoc.htm#senderr">senderr</A> (&console);
    <A href="smtdoc.htm#raise_exception">raise exception</A> (exception_event);
</PRE>

<H4>The WARNING Method</H4>

<P>The event body contains a string.  This string is handled as a
non-fatal warning message.  For example:

<PRE>
    <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "WARNING", "Exceeded connection quota");
</PRE>

<H4>The INFO Method</H4>

<P>The event body contains a string.  This string is handled as a
information message.  For example:

<PRE>
    <A href="smtdoc.htm#sendfmt">sendfmt</A> (&console, "INFO", "Connection from %s", system);
</PRE>

<H4>The LOG Method</H4>

<P>The event body contains a string that specifies the name of a
SMTLOG thread.  All operator output is sent to this thread.

<H4>SMTOPER Implementation</H4>

<P>The <A HREF="smtoper.htm">hypertext view</A> of SMTOPER's dialog
and source code may help to understand how SMTOPER works.

<A NAME="SMTTIME">&nbsp;</A>
<H3><A NAME="TOC45">The Timer Agent - SMTTIME</A></H3>

<P>Generates timing events.  You can request one timing event
after a specific delay, or repeated timing events at regular
intervals.  The timer is accurate to 1/100th of a second.  You
specify delays as a number of days and a number of
centiseconds.

<P>To use SMTTIME, call <A href="smtdoc.htm#smttime_init">smttime init</A>().  This creates a single
unnamed thread automatically the first time it is called, and has
no effect thereafter.  You can then send messages to this thread.
It supports these methods:
<UL>
<LI>ALARM - send alarm event after specified delay.
<LI>WAKEUP - send alarm event at some specific day and time.
<LI>CLOCK - send alarm events at regular intervals.
<LI>FLUSH - flush any requests for a client thread.
</UL>

<P>Example of initialising SMTTIME:

<PRE>
/*  Static data                                                 */
static QID
    timeq;                      /*  Timer agent event queue     */

    /*  In agent initialisation code                            */
    THREAD  *thread;            /*  Handle to various threads   */

    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ALARM", alarm_event, 0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ERROR", error_event, 0);

    /*  Ensure that timer agent is running, else start it       */
    <A href="smtdoc.htm#smttime_init">smttime init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TIMER, "")) != NULL)
        timeq = thread-&gt; queue-&gt; qid;
    else
        return (-1);
</PRE>

<H4>The ALARM Method</H4>

<P>Sends a single alarm event after some specified delay.  Build
the event body using exdr_write() and the message definition
SMT_TIME_ALARM.  The event body consists of these fields (see
exdr_write() for the field types):
<UL>
<LI>[q] The delay, in days.
<LI>[q] The delay, in 1/100th seconds.
<LI>[mM] An argument block, returned with the alarm event.  This
is arbitrary data, and may be NULL.
</UL>
SMTTIME replies to an ALARM event with one of these events:
<UL>
<LI>TIME_ALARM - the alarm went off.  The event body contains the
argument block, if any.  Decode the event body, if you need to,
using exdr_read() and the message definition SMT_TIME_REPLY.  The
body contains these fields: [mM] the argument block.
<LI>TIME_ERROR - there was an error that prevented the timer from
working.  This can be handled as a fatal error.  At present the
only cause for such an error is insufficient memory.  The event
body contains an error message.
</UL>
<P>The ALARM method implicitly does a FLUSH before proceeding.

<H4>The WAKEUP Method</H4>

<P>Sends a single alarm event at some specified day and time.
Build the event body using exdr_write() and the message definition
SMT_TIME_ALARM.  The event body consists of these fields (see
exdr_write() for the field types):
<UL>
<LI>[q] The alarm time in days.
<LI>[q] The alarm time in 1/100th seconds.
<LI>[mM] An argument block, returned with the alarm event.  This
is arbitrary data, and may be NULL.
</UL>
SMTTIME replies to a WAKEUP event with one of these events:
<UL>
<LI>TIME_ALARM - the alarm went off.  The event body contains the
argument block, if any.  Decode the event body, if you need to,
using exdr_read() and the message definition SMT_TIME_REPLY.  The
body contains these fields: [mM] the argument block.
<LI>TIME_ERROR - there was an error that prevented the timer from
working.  This can be handled as a fatal error.  At present the
only cause for such an error is insufficient memory.  The event
body contains an error message.
</UL>
<P>The WAKEUP method implicitly does a FLUSH before proceeding.

<H4>The CLOCK Method</H4>

<P>Sends a repeated alarm event after some specified delay, for
ever, or a specific number of times.  Build the event body using
exdr_write() and the message definition SMT_TIME_CLOCK.  The event
body consists of these fields (see exdr_write() for the field
types):
<UL>
<LI>[q] The delay, in days.
<LI>[q] The delay, in 1/100th seconds.
<LI>[w] A number of times to cycle; zero means forever.
<LI>[mM] An argument block, returned with the alarm event.  This
is arbitrary data, and may be NULL.
</UL>
SMTTIME replies to a CLOCK event with one of these events:
<UL>
<LI>TIME_ALARM - the alarm went off.  The event body contains the
argument block, if any.  Decode the event body, if you need to,
using exdr_read() and the message definition SMT_TIME_REPLY.  The
body contains these fields: [mM] the argument block.
<LI>TIME_ERROR - there was an error that prevented the timer from
working.  This can be handled as a fatal error.  At present the
only cause for such an error is insufficient memory.  The event
body contains an error message.
</UL>
<P>The CLOCK method implicitly does a FLUSH before proceeding.

<H4>The FLUSH Method</H4>

<P>Removes any requests sent by a particular client thread.  Use
this to cancel a CLOCK method, or an unexpired ALARM or WAKEUP
request.  You do not need to provide an event body, but you must
specify your thread's QID correctly when you use event_send().
SMTTIME does not reply to a FLUSH method.

<H4>Example Of Use</H4>

<P>The SMTTST1 test agent shows an example of using the timer
agent.

<H4>SMTTIME Implementation</H4>

<P>The <A HREF="smttime.htm">hypertext view</A> of SMTTIME's dialog
and source code may help to understand how SMTTIME works.

<A NAME="SMTSLOT">&nbsp;</A>
<H3><A NAME="TOC46">The Time Slot Agent - SMTSLOT</A></H3>

<P>Manages 'time slots', a mechanism to allow long-running programs
to 'switch on' and 'switch off' at specific times during the day.
The time slot agent simulates a wall timer, i.e. a timer that
switches a device like a lamp or electric heater on and off during
the day.

<P>To use SMTSLOT, call <A href="smtdoc.htm#smtslot_init">smtslot init</A>(). This does not create
any threads. Create a named thread, then send SPECIFY events to
define the various time slots for your application.  Then send an
ON or OFF event to initialise the timer.  The time slot agent then
sends a SWITCH_ON event when the timer move to an 'ON' state, and a
SWITCH_OFF event when the timer moves to an 'OFF' state.  Errors
are sent to the console, not the requesting program.  SMTSLOT
supports these methods:
<UL>
<LI>SPECIFY - define a time slot specification.
<LI>ON - initialise timer - application is switched on.
<LI>OFF - initialise timer - application is switched off.
</UL>

<P>Example of initialising SMTSLOT:

<PRE>
/*  Static data                                                 */
static QID
    slotq;                       /*  Time slot event queue      */

    /*  In agent initialisation code                            */
    THREAD  *thread;            /*  Handle to various threads   */
    /*  Ensure that time slot agent is running, else start it   */
    <A href="smtdoc.htm#smtslot_init">smtslot init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (SMT_SLOT, "myprog")) != NULL)
        slotq = thread-&gt; queue-&gt; qid;
    else
        return (-1);
</PRE>

<H4>The SPECIFY Method</H4>

<P>Defines one or more time slots.  A slot specification is a
string, in the format: "name value ...".  The name field is a day
name ("mon"-"sun"), a date in MD order ("12/31") or a date in YMD
order ("95/12/31").  The value is a list of times in 24 hour
HH:MM[-HH:MM] format ("7:30-12:30 13:30-17:30 17:35").  A value
"off" clears all time slots for that day. The time slot accuracy
is SLOT_TICK csecs.  Any day that does not have specified values
is switched 'off'.  Build the event body using exdr_write() and the
message definition SMT_SLOT_SPEC.  The event body consists of these
fields (see exdr_write() for the field types):
<UL>
<LI>[s] slot specification string.
</UL>
SMTTRAN replies to a SPECIFY event with a SLOT_ERROR event if there
was an error, else it does not reply.

<H4>The ON Method</H4>

<P>Sets the timer 'ON'.  The event does not have a body.  The timer
will respond with a SWITCH_OFF event when it moves into an 'OFF'
state.

<H4>The OFF Method</H4>

<P>Sets the timer 'OFF'.  The event does not have a body.  The
timer will respond with a SWITCH_ON event when it moves into an
'ON' state.

<H4>Example Of Use</H4>

<P>The SMTTST2 agent shows an example of using the time slot
agent.

<H4>SMTSLOT Implementation</H4>

<P>The <A HREF="smtslot.htm">hypertext view</A> of SMTSLOT's dialog
and source code may help to understand how SMTSLOT works.

<A NAME="SMTSOCK">&nbsp;</A>
<H3><A NAME="TOC47">The Socket I/O Agent - SMTSOCK</A></H3>

<P>Handles input and output to TCP and UDP sockets. You should use
this agent for all access to TCP or UDP sockets, although you can
also access sockets directly using the SFL socket access
functions.  Socket i/o is both central to most Internet servers,
and reasonably delicate, making it a task that is well done by a
specific agent.

<P>SMTSOCK has two main functions: it acts as the central
'heartbeat' for an Internet server, and it perform input and
output on sockets.  The heartbeat function works as follows:
SMTSOCK uses the select() function to monitor all open sockets.
Each socket is owned by a thread, somewhere.  When a socket shows
signs of life, SMTSOCK sends an event to the appropriate thread.
The thread can then decide to read or write data as required.  In
a typical Internet application -- such as the XITAMI web server --
the socket agent is the main source of the events that drive the
application.  By contrast, in non-Internet applications the
'heartbeat' role could be played by the timer agent SMTTIME.

<P>The second task for SMTSOCK is input and output on sockets.
For instance, you can ask SMTSOCK to read data from a socket, or
to write a block of data to a socket.  Both these tasks can
require multiple cycles, waiting until the socket is ready, then
reading/writing as much data as possible, until all the data has
been read/written.  SMTSOCK handles this automatically.

<P>To use SMTSOCK, call <A href="smtdoc.htm#smtsock_init">smtsock init</A>().  This creates a single
unnamed thread automatically the first time it is called, and has
no effect thereafter.  You can then send messages to this thread.
SMTSOCK replies to most events.  It supports these methods:
<UL>
<LI>READ - read data from a socket.
<LI>READR - read data from a socket, repeatedly.
<LI>WRITE - write data to a socket.
<LI>INPUT - wait for ready for input on a socket.
<LI>INPUTR - wait for ready for input on a socket, repeatedly.
<LI>OUTPUT - wait for ready for output on a socket.
<LI>CONNECT - make connection to specified host and port.
<LI>FLUSH - cancel any requests on a socket.
</UL>

<P>Example of initialising SMTSOCK:

<PRE>
/*  Static data                                                 */
static QID
    sockq;                      /*  Socket agent event queue    */

    /*  In agent initialisation code                            */
    THREAD  *thread;            /*  Handle to various threads   */

    /*  Reply events from socket agent                          */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_INPUT_OK",  ok_event,       0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_OUTPUT_OK", ok_event,       0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READ_OK",   read_ok_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITE_OK",  write_ok_event, 0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_CLOSED",    closed_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_ERROR",     error_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_TIMEOUT",   error_event,    0);

    /*  Ensure that socket agent is running, else start it      */
    <A href="smtdoc.htm#smtsock_init">smtsock init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_SOCKET, "")) != NULL)
        sockq = thread-&gt; queue-&gt; qid;
    else
        return (-1);
</PRE>

<H4>The READ Method</H4>

<P>Waits for, and reads data from a socket.  TCP/IP breaks a
stream of data into chunks of arbitrary size, and each low-level
read operation will read one such chunk.  Thus, to read a specific
amount of data, you may need to make several low-level read calls.
SMTSOCK packages this so that one READ event can read as much data
as required.  You can alternatively ask SMTSOCK to read just the
next chunk sent by TCP/IP.  Build the event body using
exdr_write() and the message definition SMT_SOCK_READ.  The event
body consists of these fields (see exdr_write() for the field
types):
<UL>
<LI>[d] A timeout, in seconds.  After this timeout, the read
request will be cancelled.  If zero, no timeout is applied.  Note
that this is not the same type of timeout as that you can specify
in <A href="smtdoc.htm#event_send">event send</A>().
<LI>[q] The socket to read from.  The socket must be opened and
connected.
<LI>[d] The size of the receiving buffer.  The buffer is allocated
by SMTSOCK, and can be any size up to (almost) 64K bytes.  This is
the maximum size of the returned data.
<LI>[d] The minimum amount of data to read, which can be a value
from one up to the full buffer size.  If zero, the full buffer
must be read.
<LI>[q] A user-defined request tag; this is an arbitrary token
that is returned with reply events.
</UL>
SMTSOCK replies to a READ event with one of these events:
<UL>
<LI>SOCK_READ_OK - data was read successfully.  Decode the event
body using exdr_read() and the message definition
SMT_SOCK_READ_OK. The body contains these fields: [d] timeout in
seconds from read request; [q] the socket specified for i/o; [mM]
a block of memory containing the read data; [q] the user-defined
request tag.  The SMT_SOCK_READ_OK message maps exactly to a
SMT_SOCK_WRITE message, so that you can perform an 'echo' simply
by returning the event to SMTSOCK.
<LI>SOCK_CLOSED - the socket was closed by the peer.  Data may or
may not have been read.  Decode the event as for SOCK_READ_OK.
<LI>SOCK_TIMEOUT - the read request timed-out.  Data may or may
not have been read.  Decode the event as for SOCK_READ_OK.
<LI>SOCK_ERROR - there was an error on the socket.  Any data read
is discarded.  Decode the event body using exdr_read() and the
message definition SMT_SOCK_ERROR.  The body contains these
fields: [s] a string containing the error message, [q] the socket
specified for i/o; [q] the user-defined request tag.
</UL>

<H4>The READR Method</H4>

<P>Works in the same way as the READ method, but works repeatedly
until a FLUSH is sent for the socket.  The READR method is useful
for servers that have to loop on reading a socket; it saves the
need for sending fresh READ events.

<H4>The WRITE Method</H4>

<P>Writes a block of data to a socket.  If you call the low-level
TCP/IP write function directly, you must handle various error and
retry conditions.  It is easier and safer to use SMTSOCK to do
this.  Build the event body using exdr_write() and the message
definition SMT_SOCK_WRITE.  The event body consists of these
fields:
<UL>
<LI>[d] A timeout, in seconds.  After this timeout, the write
request will be cancelled.  If zero, no timeout is applied.
<LI>[q] The socket to write to.  The socket must be opened and
connected.
<LI>[mM] The block of data to write, specified as a length and
memory address.
<LI>[q] A user-defined request tag; this is an arbitrary token
that is returned with reply events.
</UL>
SMTSOCK replies to a WRITE event with one of these events:
<UL>
<LI>SOCK_WRITE_OK - data was written successfully.  Decode the
event body using exdr_read() and the message definition
SMT_SOCK_OK. The body contains these fields: [q] the socket
specified for i/o; [q] the user-defined request tag.
<LI>SOCK_CLOSED - the socket was closed by the peer.  Data may or
may not have been written.  Decode the event as for SOCK_READ_OK.
<LI>SOCK_TIMEOUT - the write request timed-out.  Data may or may
not have been written.  Decode the event as for SOCK_READ_OK.
<LI>SOCK_ERROR - there was an error on the socket.  Data may or
may not have been written.  Decode the event body using
exdr_read() and the message definition SMT_SOCK_ERROR.  The body
contains these fields: [q] the socket specified for i/o; [s] a
string containing the error message; [q] the user-defined request
tag.
</UL>

<H4>The INPUT Method</H4>

<P>Waits for input to arrive on a socket.  This can be data, or a
connection request.  Build the event body using exdr_write() and
the message definition SMT_SOCK_INPUT.  The event body consists of
these fields:
<UL>
<LI>[d] A timeout, in seconds.  After this timeout, the input
request will be cancelled.  If zero, no timeout is applied.
<LI>[q] The socket to wait on.  The socket must be opened and
ready.
<LI>[q] A user-defined request tag; this is an arbitrary token
that is returned with reply events.
</UL>
SMTSOCK replies to an INPUT event with one of these events:
<UL>
<LI>SOCK_INPUT_OK - data is waiting on the socket.  Decode the
event body using exdr_read() and the message definition
SMT_SOCK_OK. The body contains these fields: [q] the socket
specified for i/o; [q] the user-defined request tag.
<LI>SOCK_CLOSED - the socket was closed by the peer.  Decode the
event as for SOCK_READ_OK.
<LI>SOCK_TIMEOUT - the input request timed-out.  Decode the event
as for SOCK_READ_OK.
<LI>SOCK_ERROR - there was an error on the socket.  Decode the
event body using exdr_read() and the message definition
SMT_SOCK_ERROR.  The body contains these fields: [q] the socket
specified for i/o; [s] a string containing the error message; [q]
the user-defined request tag.
</UL>

<H4>The INPUTR Method</H4>

<P>Works in the same way as the INPUT method, but works repeatedly
until a FLUSH is sent for the socket.  The INPUTR method is useful
for servers that have to loop on waiting for a socket; it saves
the need for sending fresh INPUT events.

<H4>The OUTPUT Method</H4>

<P>Waits for a socket to be ready for output.  If you use the low-
level TCP/IP write functions, you must be sure that the socket is
ready for output, or your thread will block the entire application
if it has to wait.  Build the event body using exdr_write() and
the message definition SMT_SOCK_OUTPUT.  The event body consists
of these fields:
<UL>
<LI>[d] A timeout, in seconds.  After this timeout, the output
request will be cancelled.  If zero, no timeout is applied.
<LI>[q] The socket to wait on.  The socket must be opened and
ready.
<LI>[q] A user-defined request tag; this is an arbitrary token
that is returned with reply events.
</UL>
SMTSOCK replies to an OUTPUT event with one of these events:
<UL>
<LI>SOCK_OUTPUT_OK - the socket is ready to receive data.  Decode
the event body using exdr_read() and the message definition
SMT_SOCK_OK. The body contains these fields: [q] the socket
specified for i/o; [q] the user-defined request tag.
<LI>SOCK_CLOSED - the socket was closed by the peer.  Decode the
event as for SOCK_READ_OK.
<LI>SOCK_TIMEOUT - the output request timed-out.  Decode the event
as for SOCK_READ_OK.
<LI>SOCK_ERROR - there was an error on the socket.  Decode the
event body using exdr_read() and the message definition
SMT_SOCK_ERROR.  The body contains these fields: [q] the socket
specified for i/o; [s] a string containing the error message; [q]
the user-defined request tag.
</UL>

<H4>The CONNECT Method</H4>

<P>Establishes a TCP or UDP connection to some specified host and
service (or port).  Build the event body using exdr_write() and
the message definition SMT_SOCK_CONNECT.  The event body consists
of these fields:
<UL>
<LI>[d] A timeout, in seconds.  After this timeout, the output
request will be cancelled.  If zero, no timeout is applied.
<LI>[s] The type of connection wanted: "UDP" or "TCP".
<LI>[s] The host system to connect to, specified as a name or a
dotted address string, or NULL, meaning the current system.
<LI>[s] The service to connect to, as a service name or a port
number in ASCII, or NULL, meaning use the binary port/address
information below.
<LI>[d] A 16-bit host port, or 0.
<LI>[q] A 32-bit host address, or 0.  You can supply either these
two values, or the host/service strings.  The binary port/address
data will form a connection faster.
<LI>[q] A user-defined request tag; this is an arbitrary token
that is returned with reply events.
</UL>
SMTSOCK replies to a CONNECT event with one of these events:
<UL>
<LI>SOCK_OUTPUT_OK - the socket is ready for receiving data.
Decode the event body using exdr_read() and the message definition
SMT_SOCK_OK. The body contains these fields: [q] the socket
specified for i/o; [q] the user-defined request tag.
<LI>SOCK_CLOSED - the socket was closed by the peer.  Decode the
event as for SOCK_READ_OK.
<LI>SOCK_TIMEOUT - the output request timed-out.  Decode the event
as for SOCK_READ_OK.
<LI>SOCK_ERROR - there was an error on the socket.  Decode the
event body using exdr_read() and the message definition
SMT_SOCK_ERROR.  The body contains these fields: [q] the socket
specified for i/o; [s] a string containing the error message; [q]
the user-defined request tag.
</UL>

<H4>The FLUSH Method</H4>

<P>Removes any requests for a socket.  Since events are delivered
in a straight first-in first-out basis (ignoring the high priority
SHUTDOWN event) it is safe to send first a FLUSH event, followed
by another event, with no intervening wait.  Build the event body
using exdr_write() and the message definition SMT_SOCK_FLUSH.  The
event body consists of these fields:
<UL>
<LI>[q] The socket to flush; all pending requests on this socket
are removed without further feedback.
</UL>
SMTSOCK does not reply to a FLUSH event.

<H4>Example Of Use</H4>

<P>The <A href="smtdoc.htm#SMTECHO">SMTECHO</A> agent provides a good basic example of using
<A href="smtdoc.htm#SMTSOCK">SMTSOCK</A>.  Study this program, and use it as a basis for your
own socket-based agents.

<H4>Notes and Comments</H4>
<P>The SOCK_CLOSED and SOCK_TIMEOUT return events can come from
various requests; to make processing of this possible, they are
always formatted as SOCK_READ_OK events.

<H4>SMTSOCK Implementation</H4>

<P>The <A HREF="smtsock.htm">hypertext view</A> of SMTSOCK's dialog
and source code may help to understand how SMTSOCK works.

<A NAME="SMTTRAN">&nbsp;</A>
<H3><A NAME="TOC48">The Transfer Agent - SMTTRAN</A></H3>

<P>Transfers blocks of data or files to connected sockets.  You
can use this agent to simplify certain types of communication.
The transfer agent uses the socket agent for actual reading and
writing to sockets.

<P>To use SMTTRAN, call <A href="smtdoc.htm#smttran_init">smttran init</A>().  This creates a single
unnamed thread automatically the first time it is called, and has
no effect thereafter.  You can then send messages to this thread.
It supports these methods:
<UL>
<LI>PUT_BLOCK - writes a length-specified block to a socket.
<LI>GET_BLOCK - reads a length-specified block from a socket.
<LI>PUT_FILE - writes an entire file to a socket.
<LI>GET_FILE - reads an entire file from a socket.
<LI>COMMIT - wait until all outstanding requests are
complete.
</UL>

<P>Example of initialising SMTTRAN:

<PRE>
/*  Static data                                                 */
static QID
    tranq;                      /*  Transfer agent queue        */

    /*  In agent initialisation code                            */
    THREAD  *thread;            /*  Handle to console thread    */
    /*  Ensure that transfer agent is running, else start it    */
    <A href="smtdoc.htm#smttran_init">smttran init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TRANSFER, "")) != NULL)
        tranq = thread-&gt; queue-&gt; qid;
    else
        return (-1);
</PRE>

<H4>The PUT_BLOCK Method</H4>

<P>Writes a length-specified block to a socket: first writes a
two-byte length specifier in network format, then writes the block
data.  Build the event body using exdr_write() and the message
definition SMT_TRAN_PUTB.  The event body consists of these fields
(see exdr_write() for the field types):
<UL>
<LI>[q] socket to use for output.
<LI>[mM] block of data to write to socket.
</UL>
SMTTRAN replies to a PUT_BLOCK event with one of these events:
<UL>
<LI>TRAN_PUT_OK - the block was completely written to the socket.
The event body contains the amount of data written.  Decode the
event body, if you need to, using exdr_read() and the message
definition SMT_TRAN_PUTB_OK.  The body contains these fields: [d]
the size of the block.
<LI>TRAN_CLOSED - the socket was closed before the block could be
completely written.  The event body is empty.
<LI>TRAN_ERROR - there was an error on the socket.  The event body
contains the socket error message text.
</UL>

<H4>The GET_BLOCK Method</H4>

<P>Reads a length-specified block from a socket: first reads a
two-byte length specifier in network format, then reads that many
bytes of block data.  Build the event body using exdr_write() and
the message definition SMT_TRAN_GETB.  The event body consists of
these fields (see exdr_write() for the field types):
<UL>
<LI>[q] socket to use for input.
</UL>
SMTTRAN replies to a GET_BLOCK event with one of these events:
<UL>
<LI>TRAN_GET_OK - the block was completely read from the socket.
The event body contains the data block.  Decode the event body
using exdr_read() and the message definition SMT_TRAN_GETB_OK.
The body contains these fields: [mM] the data block.
<LI>TRAN_CLOSED - the socket was closed before the block could be
completely read.  The event body is empty.
<LI>TRAN_ERROR - there was an error on the socket.  The event body
contains the socket error message text.
</UL>

<H4>The PUT_FILE Method</H4>

<P>Writes a file to a socket: reads the file in pieces of
unspecified size, and writes these to the output socket.  Build
the event body using exdr_write() and the message definition
SMT_TRAN_PUTF.  The event body consists of these fields (see
exdr_write() for the field types):
<UL>
<LI>[q] socket to use for output.
<LI>[s] name of file to write to socket.
</UL>
SMTTRAN replies to a PUT_FILE event with one of these events:
<UL>
<LI>TRAN_PUT_OK - the file was completely written to the socket.
The event body contains the amount of data written.  Decode the
event body, if you need to, using exdr_read() and the message
definition SMT_TRAN_PUTF_OK.  The body contains these fields: [q]
the size of the file.
<LI>TRAN_CLOSED - the socket was closed before the file could be
completely written.  The event body is empty.
<LI>TRAN_ERROR - there was an error on the socket or accessing the
file.  The event body contains the socket or file error message
text.
</UL>

<H4>The GET_FILE Method</H4>

<P>Reads a file from a socket and saves it with the specified
name.  Build the event body using exdr_write() and the message
definition SMT_TRAN_GETF.  The event body consists of these fields
(see exdr_write() for the field types):
<UL>
<LI>[q] socket to use for input.
<LI>[s] name of file to create.
</UL>
SMTTRAN replies to a GET_FILE event with one of these events:
<UL>
<LI>TRAN_GET_OK - the file was completely read from the socket.
The event body contains the amount of data written.  Decode the
event body, if you need to, using exdr_read() and the message
definition SMT_TRAN_GETF_OK.  The body contains these fields: [q]
the size of the file.
<LI>TRAN_CLOSED - the socket was closed before the file could be
completely read.  The event body is empty.
<LI>TRAN_ERROR - there was an error on the socket or accessing the
file.  The event body contains the socket or file error message
text.
</UL>

<H4>The COMMIT Method</H4>

<P>Waits until all put and get requests are finished, then replies
with a TRAN_CLOSED event.  This event does not take any arguments.
SMTTRAN replies to a GET_FILE event with one of these events:
<UL>
<LI>TRAN_CLOSED - no requests remain.  The event body is
empty.
<LI>TRAN_ERROR - there was an error on the socket.  The event body
contains the socket error message text.
</UL>

<H4>Example Of Use</H4>

<P>The SMTHTTP agent uses the transfer agent to send files.

<H4>SMTTRAN Implementation</H4>

<P>The <A HREF="smttran.htm">hypertext view</A> of SMTTRAN's dialog
and source code may help to understand how SMTTRAN works.

<A NAME="SMTECHO">&nbsp;</A>
<H3><A NAME="TOC49">The TCP ECHO Agent - SMTECHO</A></H3>

<P>Provides the TCP echo service on port 7.

<P>To use SMTECHO, call <A href="smtdoc.htm#smtecho_init">smtecho init</A>().  This initialises the
echo service on TCP port 7.  If you set the global variable
ip_portbase to some value before initialising SMTECHO, the echo
port is moved by that value.  For instance, if you set ip_portbase
to 8000, the echo port is 8007.  This lets you run the service in
'user space': on most systems you need root access to use ports
below 1000.

<H4>SMTECHO Implementation</H4>

<P>The <A HREF="smtecho.htm">hypertext view</A> of SMTECHO's dialog
and source code may help to understand how SMTECHO works.

<A NAME="SMTHTTP">&nbsp;</A>
<H3><A NAME="TOC50">The HTTP Agent - SMTHTTP</A></H3>

<P>Provides the HTTP service on port 80.

<P>To use SMTHTTP, call <A href="smtdoc.htm#smthttp_init">smthttp init</A>().  This initialises the
HTTP service on TCP port 80.  If you set the global variable
ip_portbase to some value before initialising SMTHTTP, the HTTP
port is moved by that value.  For instance, if you set ip_portbase
to 8000, the HTTP port is 8080.  This lets you run the service in
'user space': on most systems you need root access to use ports
below 1000.

<P>To connect to a webserver running on some system at port 8080,
use this URL: <TT>http://hostname:8080/</TT>.

<P>The current implementation of SMTHTTP is quite sophisticated.
It will look for <TT>default.htm</TT>, <TT>default.html</TT>,
<TT>index.htm</TT>, <TT>index.html</TT> in that order if no
filename is specified.  The file <TT>smthttp.aut</TT> defines
directories that are protected by username/password definitions.
You can find the full documentation for the web server in the
Xitami package.

<P>The program <TT>xitami.c</TT> is a fairly complete web server
based on the SMTHTTP agent.  You can use this program as-is, or
as a basis for your own work.

<H4>SMTHTTP Implementation</H4>

<P>The <A HREF="smthttp.htm">hypertext view</A> of SMTHTTP's dialog
and source code may help to understand how SMTHTTP works.

<A NAME="SMTSIMU">&nbsp;</A>
<H3><A NAME="TOC51">The Network Delay Simulation Agent - SMTSIMU</A></H3>

<P>Simulates network delays.  You can use SMTSIMU when you want
to test that an application will handle network delays in a robust
manner.  This can be important for applications that use the UDP
protocol, which does not provide the same traffic-control features
as TCP.

<P>SMTSIMU will insert itself invisibly between your application
agents and the socket agent when you include the file
<TT>smtsimu.h</TT> at the start of your program, after the other
include files (specifically, after <TT>smtlib.h</TT>).

<H4>SMTSIMU Implementation</H4>

<P>The <A HREF="smtsimu.htm">hypertext view</A> of SMTSIMU's dialog
and source code may help to understand how SMTSIMU works.


<H2><A NAME="TOC52">SMT API Quick Reference</A></H2>
<PRE>
SMT Quick Reference                                   Revised: 1996/12/14 PH

------------------------------------------------------------------------------
Global variables

    int     smt_errno                       Set when API detects an error
    char    *smt_errlist []                 Corresponding error messages
    event_t _the_next_event                 May be set by thread code
    event_t _the_external_event             Set by event_wait()
    event_t _the_exception_event            May be set by thread code
    Bool    _exception_raised               May be set by thread code
    Bool    _io_completed                   Last lazy I/O completed
    Bool    _repeat_module                  Repeat current action module
    Bool    signal_raised                   True after interrupt
    Bool    shutdown_pending                When kill signal in progress
    int     signal_value                    Value of signal

------------------------------------------------------------------------------
AGENT
    AGENT  *next, *prev;                    Doubly-linked list
    NODE    methods;                        Methods accepted by agent
    NODE    queues;                         Queues defined for agent
    char   *name;                           Agent's name
    Bool    router;                         True if multi-thread/queue
    int     priority;                       50=Low, 100=Normal, 200=High
    long    max_threads;                    Max. permitted threads, or 0
    long    cur_threads;                    Current number of threads
    long    top_threads;                    Max. number threads we had
    long    thread_tally;                   How many threads created
    long    switch_tally;                   How many context switches

------------------------------------------------------------------------------
METHOD
    METHOD *next, *prev;                    Doubly-linked list
    AGENT  *agent;                          Parent agent descriptor
    char   *name;                           Name of method
    int     priority;                       50=Low, 100=Normal, 200=High
    int     event_number;                   Internal event number

------------------------------------------------------------------------------
QID
    long node;                              Location of queue (zero)
    long ident;                             Queue ID number (1..n)

------------------------------------------------------------------------------
QUEUE
    QUEUE  *next, *prev;                    Doubly-linked list
    AGENT  *agent;                          Parent agent descriptor
    NODE    events;                         Events in queue
    NODE    threads;                        Threads for queue
    QID     qid;                            Queue ID descriptor
    int     max_events;                     Maximum allowed events
    int     cur_events;                     Current number of events

------------------------------------------------------------------------------
EVENT
    EVENT  *next, *prev;                    Doubly-linked list
    QUEUE  *queue;                          Parent queue descriptor
    QID     sender;                         Replies come back here
    char   *name;                           Name of event
    size_t  body_size;                      Size of event body in bytes
    byte   *body;                           Event body
    char   *accept_event;                   Reply if we accept event
    char   *reject_event;                   Reply if we reject event
    char   *expire_event;                   Reply if we expire event
    time_t  timeout;                        Expires at this time (or 0)

------------------------------------------------------------------------------
THREAD Properties
    THREAD  *next, *prev;                   Doubly-linked list
    QUEUE   *queue;                         Parent queue descriptor
    long     thread_id;                     Thread identifier number
    char    *name;                          Name of thread
    Bool     animate;                       Animate this thread
    void    *tcb;                           Thread context block (TCB)
    EVENT   *event;                         Last-received event

------------------------------------------------------------------------------
SEMAPH Properties
    SEMAPH  *next, *prev;                   Doubly-linked list
    char    *name;                          Name of semaphore

------------------------------------------------------------------------------
Function Prototypes

int      smt_init           (void);
int      smt_term           (void);
int      smt_exec_full      (void);
Bool     smt_exec_step      (void);
Bool     smt_active         (void);
void     smt_set_console    (QID *qid);
void     smt_set_timer      (QID *qid);
int      smt_atexit         (function exitfct);
void     smt_shutdown       (void);
AGENT   *agent_declare      (char *agent);
AGENT   *agent_lookup       (char *agent);
int      agent_destroy      (AGENT *agent);
METHOD  *method_declare     (AGENT *agent, char *method, int nbr, int priority);
METHOD  *method_lookup      (AGENT *agent, char *method);
int      method_destroy     (METHOD *method);
QUEUE   *queue_create       (AGENT *agent, int max_events);
QUEUE   *queue_lookup       (QID *qid);
int      queue_destroy      (QUEUE *queue);
int      queue_flush        (QUEUE *queue);
int      event_send         (QID *to, QID *from, char *name, byte *body,
                             size_t body_size, char *accept, char *reject,
                             char *expire, word timeout);
EVENT   *event_accept       (QUEUE *queue, EVENT *event);
int      event_reject       (QUEUE *queue, EVENT *event);
int      event_expire       (QUEUE *queue, EVENT *event);
int      event_discard      (QUEUE *queue, EVENT *event);
EVENT   *event_iterate      (QUEUE *queue, EVENT *event);
int      event_destroy      (EVENT *event);
void     event_wait         (void);
THREAD  *thread_create      (char *agent, char *thread);
THREAD  *thread_lookup      (char *agent, char *thread);
int      thread_destroy     (THREAD *thread, Bool cleanup);
SEMAPH  *semaph_create      (char *name, int value);
SEMAPH  *semaph_lookup      (char *name);
int      semaph_destroy     (SEMAPH *semaph);
int      semaph_wait        (SEMAPH *semaph);
int      semaph_signal      (SEMAPH *semaph);
int      lazy_creat         (char *path, int mode);
int      lazy_open          (char *path, int flags);
int      lazy_read          (int handle, char *buffer, size_t count);
int      lazy_write         (int handle, char *buffer, size_t count);
int      lazy_close         (int handle);
int      senderr            (QID *to_queue);
int      sendfmt            (QID *to_queue, char *name, char *format,...);
void     raise_exception    (event_t event);
void     recycle_module     (Bool wanted);

#define  SEND(q,name,s)     event_send ((q), NULL, (name), (byte *) (s),                                         strlen(s) + 1, NULL, NULL, NULL, 0)

------------------------------------------------------------------------------
Constants

    Possible values for smt_errno
    SMT_NOERRORS            0               No errors
    SMT_EVENTEXISTS         1               Event already declared
    SMT_INTERNALERROR       2               Agent had internal error
    SMT_METHODEXISTS        3               Method already declared
    SMT_NOSUCHEVENT         4               Unknown event name
    SMT_NOSUCHMETHOD        5               Unknown method name
    SMT_NOSUCHQUEUE         6               Event queue not defined
    SMT_NOSUCHSEMAPH        7               Unknown semaphore name
    SMT_NOSUCHAGENT         8               Agent not defined
    SMT_NOSUCHTHREAD        9               Thread not declared
    SMT_NOTREADY            10              SMT API not initialised
    SMT_OUTOFMEMORY         11              Not enough heap memory left
    SMT_QUEUEISEMPTY        12              Event queue is empty
    SMT_QUEUEISFULL         13              Event queue is full
    SMT_SEMAPHEXISTS        14              Semaphore already exists
    SMT_AGENTEXISTS         15              Agent already declared
    SMT_AGENTNOTREADY       16              Agent not initialised
    SMT_THREADEXISTS        17              Thread already declared
    SMT_TOOMANYTHREADS      18              Too many threads

    Values for priority arguments
    SMT_PRIORITY_NULL       0               Illegal (null) priority
    SMT_PRIORITY_MIN        1               Lowest priority
    SMT_PRIORITY_LOW        50              Low priority
    SMT_PRIORITY_NORMAL     100             Default priority
    SMT_PRIORITY_HIGH       200             High priority
    SMT_PRIORITY_MAX        255             Highest priority

    Values for agent_declare () type argument
    SMT_AGENT_NORMAL        0               1 queue for 1 thread
    SMT_AGENT_ROUTER        1               1 queue for n threads

    Event constants
    SMT_NULL_EVENT          -2              No event for method

------------------------------------------------------------------------------
    SMTLOG - Logging Agent
        One thread per log file; create thread with log file name, or supply
        log file name in CYCLE, OPEN, APPEND events.  Filename "" or "NULL"
        means discard all log file output.  Errors are sent to SMTOPER.

    Method:                         Body:           Replies:
    CYCLE    Cycle log file         [file name]     -
    OPEN     Open new log file      [file name]     -
    APPEND   Append to existing     [file name]     -
    PUT      Write line to log      Line of text    -
    PLAIN    Do not timestamp log   -               -
    STAMP    Timestamp each line    -               -
    CLOSE    Close log file         -               -

    SMT_LOGGING             "smtlog"        Name of logging agent
    int smtlog_init         (void);         Logging agent

------------------------------------------------------------------------------
    SMTOPER - Operator Console Agent
        Single unnamed thread created automatically when agent initialises.
        Send messages to console device or log file if specified.

    Method:                         Body:             Replies:
    ERROR    Error message          Message           -
    WARNING  Warning message        Message           -
    INFO     Information message    Message           -
    LOG      Redirect to log file   SMTLOG thread name  -

    SMT_OPERATOR            "smtoper"       Name of operator agent
    int smtoper_init        (void);         Operator agent

------------------------------------------------------------------------------
    SMTTIME - Timer Agent
        Single unnamed thread created automatically when agent initialises.
        Accurate to 1/100th second.

    Method:                         Body:             Replies:
    ALARM    Alarm after delay      SMT_TIME_ALARM    TIME_ALARM, TIME_ERROR
    WAKEUP   Alarm at some time     SMT_TIME_ALARM    TIME_ALARM, TIME_ERROR
    CLOCK    Alarm at intervals     SMT_TIME_CLOCK    TIME_ALARM, TIME_ERROR

    Replies:                                    Body:
    TIME_ALARM      Alarm went off              SMT_TIME_REPLY
    TIME_ERROR      Insufficient memory         Error message

    SMT_TIMER               "smttime"       Name of timer agent
    int smttime_init        (void);         Timer agent

    SMT_TIME_ALARM          "qqmM"
    q=time/delay in days
    q=time/delay in 1/100th seconds
    mM=user-defined data block, returned with reply event

    SMT_TIME_CLOCK          "qqwmM"
    q=delay in days
    q=delay in 1/100th seconds
    w=number of times to cycle - zero means forever
    mM=user-defined data block, returned with reply event

    SMT_TIME_REPLY          "mM"
    mM=user-defined data block, returned with reply event

------------------------------------------------------------------------------
    SMTSLOT - Time Slot Agent
        One thread per application; create thread with application name.
        Send SPECIFY events, then ON or OFF to set timer initial state.
        Specification is "name values..."; name is "mon" to "sun", or date
        in MM/DD, YY/MM/DD, or YYYY/MM/DD format.  Values are hh:mm[-hh:mm]
        in 24-hour clock format, delimited by spaces.

    Method:                         Body:             Replies:
    SPECIFY  Specify time slot      Specification     SLOT_ERROR, if error
    ON       Error message          -                 SWITCH_ON, SWITCH_OFF
    OFF      Error message          -                 SWITCH_ON, SWITCH_OFF

    SMT_SLOT                "smtslot"       Name of time slot agent
    int smtslot_init        (void);         Time slot agent

    SMT_SLOT_SPEC           "s"
    s=day of week, mm/dd, or yy/mm/dd followed by 1 or more time specs

------------------------------------------------------------------------------
    SMTSOCK - Socket I/O Agent
        Single unnamed thread created automatically when agent initialises.
        Multiple writes are processed in order; multiple reads are collapsed.

    Method:                         Body:             Replies:
    READ     Read socket data       SMT_SOCK_READ     SOCK_READ_OK,...
    READR    Read, repeat for ever  SMT_SOCK_READ     SOCK_READ_OK,...
    WRITE    Write socket data      SMT_SOCK_WRITE    SOCK_WRITE_OK,...
    INPUT    Wait for input         SMT_SOCK_INPUT    SOCK_INPUT_OK,...
    INPUTR   Wait input, repeat     SMT_SOCK_INPUT    SOCK_INPUT_OK,...
    OUTPUT   Wait for output        SMT_SOCK_OUTPUT   SOCK_OUTPUT_OK,...
    CONNECT  Connect to host        SMT_SOCK_CONNECT  SOCK_WRITE_OK,...
    FLUSH    Flush requests         SMT_SOCK_FLUSH    -

    Replies:                                    Body:
    SOCK_READ_OK    Data read okay              SMT_SOCK_READ_OK
    SOCK_WRITE_OK   Data written okay           SMT_SOCK_OK
    SOCK_INPUT_OK   Socket has input ready      SMT_SOCK_OK
    SOCK_OUTPUT_OK  Socket ready for output     SMT_SOCK_OK
    SOCK_CLOSED     Socket was closed           SMT_SOCK_READ_OK
    SOCK_TIMEOUT    Request timed-out           SMT_SOCK_READ_OK
    SOCK_ERROR      Socket error during read    SMT_SOCK_ERROR

    SMT_SOCKET              "smtsock"       Name of socket i/o agent
    int smtsock_init        (void);         Socket i/o agent
    void smtsock_trace      (Bool trace);   Socket i/o agent trace on/off

    SMT_SOCK_READ           "dqddq"
    d=timeout, in seconds - zero means no timeout
    q=socket to read from
    d=size of receiving buffer
    d=minimum amount of data to read, 1 - buffer size; zero = all
    q=user-defined request tag

    SMT_SOCK_WRITE          "dqmMq"
    d=timeout, in seconds - zero means no timeout
    q=socket to write to
    mM=block of memory to write to the socket
    q=user-defined request tag

    SMT_SOCK_INPUT          "dqq"
    d=timeout, in seconds - zero means no timeout
    q=socket to wait on
    q=user-defined request tag

    SMT_SOCK_OUTPUT         "dqq"
    d=timeout, in seconds - zero means no timeout
    q=socket to wait on
    q=user-defined request tag

    SMT_SOCK_CONNECT        "dsssdqq"
    d=timeout, in seconds - zero means no timeout
    s=type, UDP or TCP
    s=host, specified as name or dotted address, or NULL
    s=service, as name or port number in ASCII, or NULL
    d=16-bit host port, or 0
    q=32-bit host address, or 0  -- one of these pairs is required
    q=user-defined request tag

    SMT_SOCK_FLUSH          "q"
    q=socket to flush requests for

    SMT_SOCK_READ_OK        "dqmMq"
    d=timeout, in seconds, from read request
    q=socket specified for i/o
    mM=block of memory
    q=user-defined request tag

    SMT_SOCK_OK             "qq"
    q=socket specified for i/o, or new connected socket
    q=user-defined request tag

    SMT_SOCK_ERROR          "sqq"
    s=error message
    q=socket specified for i/o, or new connected socket
    q=user-defined request tag

------------------------------------------------------------------------------
    SMTTRAN - Transfer Agent
        Single unnamed thread created automatically when agent initialises.
        Transfers fixed-size blocks or complete files.

    Method:                         Body:             Replies:
    PUT_BLOCK   Write block         SMT_TRAN_PUTB     SMT_TRAN_PUTB_OK,...
    GET_BLOCK   Read block          SMT_TRAN_GETB     SMT_TRAN_GETB_OK,...
    PUT_FILE    Write file          SMT_TRAN_PUTF     SMT_TRAN_PUTF_OK,...
    GET_FILE    Read file           SMT_TRAN_GETF     SMT_TRAN_GETF_OK,...
    COMMIT      Finish transfers    -                 -

    SMT_TRANSFER            "smttran"       Name of transfer agent
    int smttran_init        (void);         TCP/IP transfer agent

    SMT_TRAN_PUTB           "qmM"
    q=socket for output
    mM=block of data to transmit

    SMT_TRAN_GETB           "q"
    q=socket for input

    SMT_TRAN_PUTF           "qs"
    q=socket for output
    s=name of file to send

    SMT_TRAN_GETF           "qs"
    q=socket for input
    s=name of file to receive

    SMT_TRAN_PUTB_OK        "d"
    d=size of transmitted data

    SMT_TRAN_GETB_OK        "mM"
    mM=received block of data

    SMT_TRAN_PUTF_OK        "q"
    q=size of transmitted data

    SMT_TRAN_GETF_OK        "q"
    q=size of received data
</PRE>

<H2><A NAME="TOC53">The Unattended Process Monitor (UPM) Tool</A></H2>

<H3><A NAME="TOC54">Overview</A></H3>

<P>The UPM tool is a small application developed with SMT, and
included as an example.  The UPM tool was developed on UNIX and may
not be very useful on other systems.

<P>The UPM tool allows you to manage 'unattended' processes, which
may handle input/output on some devices, typically terminals.  The
UPM tool lets you start and stop such processes, manually or using
a timer.

<H3><A NAME="TOC55">Technical Details</A></H3>

<P>The UPM tool consists of four programs:
<OL>
<LI><TT>upmd</TT> is a server program that runs permanently.
<LI><TT>upmc</TT> is a client program that provides a command-level
interface.
<LI><TT>smtupmd</TT> is an agent that handles the UPM server
protocol.  The <TT>upmd</TT> program is basically a wrapper around
this agent.
<LI><TT>smtupmc</TT> is an agent that handles the UPM client
protocol.  The <TT>upmc</TT> program is basically a wrapper around
this agent.
</OL>

<P>The main UPM configuration file is called "upm.ini".  This is
a typical "upm.ini" file:
</PRE>[Setup]
    logfile=upmd.log
[Tasks]
    name=task1
    name=task2
</PRE>

<P>The [Tasks] section defines each of the UPM tasks.  Each task
has a config file to define task-specific values. The config file
for "task1" is called "TASK1.ini". For example:
<PRE>#   Configuration for Task 1
[Setup]
    stdin=/dev/pts/1
    stdout=/dev/pts/1
    stderr=/dev/pts/1
[Environment]
    DATABASE=test
    PRINTER=tcp://localhost:1000
[Run]
    idle=banner IDLE
    startup=run BBORNE.gnt
    cancel=cleanup
</PRE>

<P>The [Setup] section defines the input/output devices for the
task.  The [Environment] section defines a list of variables for
the task.  The [Run] section defines the idle command and the
startup command.  These commands must be executable files (scripts
or programs) with optional arguments.  Redirection or multiple
commands are not permitted.

<P>Each task also has an optional TIMES file.  The times file for
task1 is called "TASK1.tim", and looks something like this:
<PRE>#  This file specifies the times for Task1

mon 8-12 12:30-20
tue 8-12 12:30-20
wed 8-12 12:30-20
thu 8-12 13:05-13:06  13:08:13-10
fri 8-12 12:30-20
12/25 off
1/1 off
</PRE>

<P>Each line (except blank lines and comments) defines some times
for a day.  The first word on the line is the <EM>day</EM>, the
remaining words are one or more time <EM>specifications</EM>.  A
day can be:
<UL>
<LI>A day name, Mon-Sun.
<LI>A date, MM/DD or YY/MM/DD or YYYY/MM/DD.  If you use YY/MM/DD,
the century is assumed to be 20 for years higher than 50.
</UL>
A time specification can be:
<UL>
<LI>'off', meaning clear all times for that day.
<LI>hh:mm-hh:mm, meaning activate for that time range, inclusive.
</UL>

<P>If no TIMES file is provided, you can (or rather, must) start
and stop the tasks manually.

<H3><A NAME="TOC56">Using The UPM Tool</A></H3>

<OL>
<LI>Define the upm.ini and task .ini files correctly.  Make sure
that the devices exist and are writable.
<LI>For testing, run the <TT>upmd</TT> program in a shell window.
For real life use, place into the system startup procedure
(<TT>inittab</TT> on a UNIX system).  You can run <TT>upmd</TT> in
the background like this (assuming a UNIX system):

<PRE>nohup upmd&
</PRE>

<P>Run the command <TT>upmc</TT> to start the BORMAN client.  The
<TT>upmc<TT> program acts as a 'front-end' for the upmd daemon.
Since the daemon runs as a process in the background, it cannot
read commands from the keyboard itself.

<P>When you run <TT>upmc<TT> you get a message like this:
<PRE>upmc> 100- Connecting to UPM daemon...
upmc> 102- Connected to UPM daemon version 1.0
upmc></PRE>

<P>You can give various commands at the prompt.  This is what the
'help' command shows:
<PRE>upmc> help
Commands and arguments can be in any case.  Commands are:
LIST                 - list all known tasks
START [task | ALL]   - start specified task (default all)
STOP [task | ALL]    - stop specified task (default all)
STATUS [task | ALL]  - show status for specified task (default all)
HALT                 - halt UPM daemon
EXIT                 - end this UPM client session
QUIT                 - end this UPM client session
HELP                 - show this information
VERSION              - show UPM client version
</PRE>

<P>If you run <TT>upmc<TT> when the <TT>upmd<TT> daemon is not
running, you get this:
<PRE>upmc> 100- Connecting to UPM daemon...
upmc> 301- UPD daemon connection failed: Connection refused
</PRE>

<P>You can also run <TT>upmc<TT> to execute a command directly:
<PRE>$ upmc start all
</PRE>
Which is the same as typing this:
<PRE>$ upmc start
</PRE>

<H3><A NAME="TOC57">UPM Trouble Shooting</A></H3>

<P>These are some possible errors:
<UL>
<LI>The device you specified in the task .ini file is not
accessible to the upm daemon.  You will get an error message in the
daemon log file, or in the shell window where you ran
<TT>upmd</TT>.
<LI>The commands you specified in the task .ini file are not found
or not accessible.  You will get an error message in the daemon log
file, or in the shell window where you ran <TT>upmd<TT>.
</UL>

<H4>UPM Implementation</H4>

<P>The <A HREF="smtupmd.htm">hypertext view</A> of SMTUPMD's dialog
and source code may help to understand how SMTUPMD works.

<P>The <A HREF="smtupmc.htm">hypertext view</A> of SMTUPMC's dialog
and source code may help to understand how SMTUPMC works.


<A NAME="download">&nbsp;</A>

<H2><A NAME="TOC58">Installing The SMT Kernel</A></H2>

<H3><A NAME="TOC59">Availability and Distribution</A></H3>

<P>We supply the SMT kernel as two archives: a source kit and a
documentation kit (in HTML).  These files are available for
download by HTTP from our <A href="http://www.imatix.com/">website</A> on a permanent basis.
You need to recompile the SMT for your specific system, using an
ANSI C compiler.  We don't provide binary kits.

<P>To install and use the SMT kernel you must first install the
<A href="/html/sfl/">SFL package</A>.  SMT requires the current version of the
SFL.  To write SMT programs you also need to install the
<A href="/html/libero/">Libero</A> tool.

<H4>Getting The Source Archive</H3>

<P>The SMT source archive is supplied as a <A href="/pub/smt/src/smtsrc28.zip">zip file</A>
and a <A href="/pub/smt/src/smtsrc28.tgz">GNU gzipped tar file</A>.  Note that the zipped files
are in MS-DOS format (carriage-return, linefeed) while the gzip+tar
file is in UNIX format (linefeed only).  The unzip command allows
you to extract correctly for the system you are running on.
These are the files in the /pub/smt/src directory:
<PRE>
<A href="/pub/smt/src/smtsrc27.tgz">smtsrc27.tgz </A>   506536 100/04/01 16:17:32  Gzip/tar archive
<A href="/pub/smt/src/smtsrc27.zip">smtsrc27.zip </A>   649300 100/04/01 16:17:32  ZIP archive
<A href="/pub/smt/src/smtsrc28.tgz">smtsrc28.tgz </A>   568875 99/08/08 12:05:32  Gzip/tar archive
<A href="/pub/smt/src/smtsrc28.zip">smtsrc28.zip </A>   768325 99/12/30 14:08:55  ZIP archive
</PRE>

<P>If you have trouble accessing the iMatix site, send us an
<A href="mailto:info@imatix.com">e-mail</A> and we'll send you the SMT archives by return
e-mail.

<H4>Getting The The Documentation Kit</H3>

<P>The SMT documentation is supplied as HTML files, available
on-line or off-line as a <A href="/pub/smt/doc/smtdoc28.zip">single .zip file</A> that
you can install on a hard disk for rapid access, and also as
a <A href="/pub/smt/doc/smtdoc28.tgz">gzipped tar file</A>.  These are the files in the
/pub/smt/doc directory:
<PRE>
<A href="/pub/smt/doc/smtbig27.tgz">smtbig27.tgz </A>    80744 100/04/01 16:17:33  Gzip/tar archive
<A href="/pub/smt/doc/smtbig27.zip">smtbig27.zip </A>    80860 100/04/01 16:17:33  ZIP archive
<A href="/pub/smt/doc/smtbig28.tgz">smtbig28.tgz </A>    80419 99/08/08 12:05:38  Gzip/tar archive
<A href="/pub/smt/doc/smtbig28.zip">smtbig28.zip </A>    80592 99/08/08 12:04:52  ZIP archive
<A href="/pub/smt/doc/smtdoc27.tgz">smtdoc27.tgz </A>   168262 100/04/01 16:17:33  Gzip/tar archive
<A href="/pub/smt/doc/smtdoc27.zip">smtdoc27.zip </A>   286443 100/04/01 16:17:32  ZIP archive
<A href="/pub/smt/doc/smtdoc28.tgz">smtdoc28.tgz </A>   168362 99/08/08 12:05:50  Gzip/tar archive
<A href="/pub/smt/doc/smtdoc28.zip">smtdoc28.zip </A>   286546 99/08/08 12:04:52  ZIP archive
</PRE>

<P>We recommend that you unzip or gunzip/detar the documentation
archive into a subdirectory.  Then, point your browser at the
<TT>index.htm</TT> file to access the documentation.  We use
relative addressing in all HTML documents, so that links work just
as well on a local hard-disk (without a web server) as on-line on
our website.  In a windowing environment is it easy and useful to
create an icon that launches a Web browser on this file.

<H3><A NAME="TOC60">Installation for UNIX Systems</A></H3>

<P>To install the SMT kernel on a UNIX system you need to:
<OL>
<LI>Install the <A href="/html/sfl/">SFL package</A>: you will want to place
<TT>libsfl.a</TT> and <TT>sfl.h</TT> in the current directory.

<LI>Download the SMT source archive and decompress it.
<LI>Run the 'build' script to compile the SMT sources and build
the libsmt.a archive file and various executables.
</OL>

<H4>Decompressing The Source Archive</H4>

<P>To unzip the <A href="/pub/smt/src/smtsrc28.zip">source .zip file</A>, you need the Infozip
<A href="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> tool:
<PRE>$ mkdir temp
$ mv smtsrc28.zip temp
$ cd temp
$ unzip -a smtsrc28
</PRE>

<P>To decompress the <A href="/pub/smt/src/smtsrc28.tgz">source archive</A> you need GNU gzip/gunzip
and tar:
<PRE>$ mkdir temp
$ mv smtsrc28.tgz temp
$ cd temp
$ gzip -d smtsrc28.tgz
  or
$ gunzip smtsrc28.tgz
$ tar -xvf smtsrc28.tar
</PRE>

<P>You can also, in extreme cases, unzip the files on a PC and
transfer the individual files to the UNIX system.

<H4>Compiling The SMT Sources</H4>

<P>To compile the SMT sources, use this command:
<PRE>$ chmod +x build
$ build
</PRE>

<P>If you get warnings or error messages, this is usually a bad
sign.  Some compilers issue warnings just because you ask for ANSI
compilation.  If you get any other error messages, please let us
know.

<P>The SMT source archive includes a script, <TT><B>c</B></TT>,
that you can (and should) use to compile an individual SMT source.
This script invokes the ANSI C compiler to produce an object code
file. It detects the platform and invokes the compiler with the
necessary switches for ANSI C compilation.  On some systems this
is the normal behaviour for the <B>cc</B> command.  On other
systems it is not normal.  You should make the <TT>c</TT> script
executable, (preferrably) install it in a shared directory like
/usr/local/bin, and try it out:
<PRE>$ chmod a+rx c
$ mv c /usr/local/bin
$ c
</PRE>

<P>The <TT>c</TT> script is also included in the SFL package.

<H3><A NAME="TOC61">Installation for Digital VMS Systems</A></H3>

<P>SMT has not been tested on Digital VMS systems.  However, it
should be portable, especially to later versions of VMS that are
POSIX compliant.  To install the SMT on a Digital VMS system you
need to:
<OL>
<LI>Install the SFL package: you will want to place
<TT>libsfl.olb</TT> and <TT>sfl.h</TT> in the current
directory.
<LI>Download the source archive and decompress it.
<LI>Run the 'build.txt' command file to build the libsmt.olb
library file and the various executables.
</OL>

<H4>Decompressing The Source Archive</H4>

<P>To unzip the <A href="/pub/smt/src/smtsrc28.zip">source .zip file</A>, you need the Infozip
<A href="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> tool:
<PRE>$ create/dir [.temp]
$ ren smtsrc28.zip [.temp]
$ set def [.temp]
$ unzip -a smtsrc28
</PRE>

<P>You can also, in extreme cases, unzip the files on a PC and
transfer the individual files to the VMS system.

<H4>Compiling The SMT Sources</H4>

<P>To compile the SMT sources, use this command:
<PRE>$ @build.txt
</PRE>

<P>Note: this command file has not yet been tested, so it would be
a little surprising if it worked.  Nonetheless, the work it does
is simple: compile all .c programs, then link a couple of main
programs.  If you get warnings or error messages, this is a bad
sign - please let us know.

<H3><A NAME="TOC62">Installation for Windows</A></H3>

<P>Our preferred way of working is to build the SFL as a static
library, and do the same for the SMT kernel.  Using a typical
Windows-hosted compiler, we create two projects.  Then, we create a
project for each main program.  For instance, we create a project
each for the echod and echocli programs.  In these projects, we
refer to the SFL and SMT library files.  While the SFL and SMT
libraries compile fine under 16-bit Windows, the link phase usually
gives problems, and we prefer to work with a 32-bit memory model.
All SMT programs, including the Xitami web server, run as 32-bit
console processes under Windows NT and 95.

<H2><A NAME="TOC63">System-Specific Concerns</A></H2>

<P>This section notes constraints that we've come across on
various systems.  This is not meant to be a complete list of all
possible problems.

<H3><A NAME="TOC64">Windows</A></H3>

<H4>SMTSOCK and the select() call</H4>

<P>SMTSOCK uses the select() call to wait for socket events.  On
UNIX systems, select() returns when the process receives a signal.
We use this fact to implement the process timer, SMTTIME, in an
application that may also be doing socket i/o.

<P>Under Windows 95, however, the select() call does not unblock
when a signal is sent.  The winsock call WSACancelBlockingCall()
is meant to unblock the select() call.  This does not work under
Windows 95, at least.  (WSAIsBlocking() always reports FALSE.)

<P>The consequence of this is that the timeout specified in the
select() call makes a difference to the way that the timer work.
If we use a 1-second timeout, for instance, we find that timer
events are also limited to a resolution of 1 second.  This makes
it difficult to use timer events for real-time work in socket
based applications.

<P>This appears to be a bug in the Windows 95 winsock.dll; it
may also affect Windows NT.

<P>Our solution is to use WSACancelBlockingCall() in any case,
should the winsock.dll support it correctly.  Secondly, under
Windows, we reduce the select() timeout from 1 second to 1/5th
of a second.  On other systems - UNIX, OS/2 - we use 1 second,
so that the application uses minimal system resources.

<A NAME="license">&nbsp;</A>
<H2><A NAME="TOC65">The SMT License Agreement</A></H2>

<P>This license agreement covers your use of the iMatix <EM>SIMPLE
MULTITHREADING KERNEL (SMT)</EM>, its source code, documentation, and
executable files, hereinafter referred to as <EM>"the Product"</EM>.

<P>The Product is Copyright &#169; 1991-2000 iMatix Corporation. You may use
it and distribute it according to this following License Agreement. If you
do not agree with these terms, please remove the Product from your system.
By incorporating the Product in your work or distributing the Product to
others you implicitly agree to these license terms.

<H3>Statement Of Copyright</H3>

<P>The Product is, and remains, Copyright &#169; 1991-2000 iMatix Corporation,
with exception of specific copyrights as noted in the individual source
files.

<H3>Conditions Of Use</H3>

<P>You do not need to provide the source code for the Product as part of
your product. However, you must do one of these things to comply with the
Product License Agreement:
<OL>
<LI>Provide the source code for Product modules that you use, or
<LI>Make your product freely available according to a license similar to the
GNU General Public License, or the Perl Artistic License, or
<LI>Add this phrase to the documentation for your product:
<EM>"This product uses parts of the iMatix SMT kernel, Copyright
&#169; 1991-2000 iMatix Corporation &lt;http://www.imatix.com&gt;"</EM>.
</OL>

<H3>Rights Of Usage</H3>

<P>You may freely and at no cost use the Product in any project, commercial,
academic, military, or private, so long as you respect the License
Agreement. The License Agreement does not affect any software except the
Product. In particular, any application that uses the Product does not
itself fall under the License Agreement.

<P>You may modify any part of the Product, including sources and
documentation, except this License Agreement, which you may not modify.

<P>You must clearly indicate any modifications at the start of
each source file.  The user of any modified Product code must know
that the source file is not original.

<P>At your discretion, you may rewrite or reuse any part of the
Product so that your derived code is not obviously part of the
Product.  This derived code does not fall under the Product
License Agreement directly, but you must include a credit at the
start of each source file indicating the original authorship and
source of the code, and a statement of copyright as follows:<BR>
<EM>"Parts copyright (c) 1991-2000 iMatix Corporation."</EM>

<H3>Rights Of Distribution</H3>

<P>You may freely distribute the Product, or any subset of the Product, by
any means. The License, in the form of the file called "LICENSE.TXT" must
accompany any such distribution.

<P>You may charge a fee for distributing the Product, for providing a
warranty on the Product, for making modifications to the Product, or for any
other service provided in relation to the Product. You are not required to
ask our permission for any of these activities.

<P>At no time will iMatix Corporation associate itself with any distribution
of the Product except that supplied from the Internet site
http://www.imatix.com.

<H3>Disclaimer Of Warranty</H3>

<P>The Product is provided as free software, in the hope that it will be
useful. It is provided "as-is", without warranty of any kind, either
expressed or implied, including, but not limited to, the implied warranties
of merchantability and fitness for a particular purpose. The entire risk as
to the quality and performance of the Product is with you. Should the
Product prove defective, the full cost of repair, servicing, or correction
lies with you.
<H2><A NAME="TOC66">SMT Kernel API functions</A></H2>
<P>Filename: smtlib.h
<BR>Package: Libero SMT 2.x
<BR>Written: 1996/05/27 iMatix SMT kernel team <A
   HREF=mailto:"smt@imatix.com">smt@imatix.com</A>
<BR>Revised: 1999/08/01
<BR>Copyright: Copyright (c) 1991-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Defines the functions and objects used in the SMT kernel API.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="smtdoc.htm#smt_init">smt init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smt_term">smt term</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smt_exec_full">smt exec full</A><BR>
   (void);
</LI>
<LI>Bool <A href="smtdoc.htm#smt_exec_step">smt exec step</A><BR>
   (void);
</LI>
<LI>Bool <A href="smtdoc.htm#smt_active">smt active</A><BR>
   (void);
</LI>
<LI>void <A href="smtdoc.htm#smt_set_console">smt set console</A><BR>
   (const QID *qid);
</LI>
<LI>void <A href="smtdoc.htm#smt_set_timer">smt set timer</A><BR>
   (const QID *qid);
</LI>
<LI>int <A href="smtdoc.htm#smt_atexit">smt atexit</A><BR>
   (function exit_function);
</LI>
<LI>void <A href="smtdoc.htm#smt_shutdown">smt shutdown</A><BR>
   (void);
</LI>
<LI>char * <A href="smtdoc.htm#smt_crash_report">smt crash report</A><BR>
   (void);
</LI>
<LI>void <A href="smtdoc.htm#smt_set_step">smt set step</A><BR>
   (const char *step);
</LI>
<LI>AGENT * <A href="smtdoc.htm#agent_declare">agent declare</A><BR>
   (const char *agent_name);
</LI>
<LI>AGENT * <A href="smtdoc.htm#agent_lookup">agent lookup</A><BR>
   (const char *agent);
</LI>
<LI>int <A href="smtdoc.htm#agent_destroy">agent destroy</A><BR>
   (AGENT *agent);
</LI>
<LI>METHOD * <A href="smtdoc.htm#method_declare">method declare</A><BR>
   (AGENT *agent, const char *method_name, event_t number, int
   priority);
</LI>
<LI>METHOD * <A href="smtdoc.htm#method_lookup">method lookup</A><BR>
   (const AGENT *agent, const char *method);
</LI>
<LI>int <A href="smtdoc.htm#method_destroy">method destroy</A><BR>
   (METHOD *method);
</LI>
<LI>QUEUE * <A href="smtdoc.htm#queue_create">queue create</A><BR>
   (AGENT *agent, int max_events);
</LI>
<LI>QUEUE * <A href="smtdoc.htm#queue_lookup">queue lookup</A><BR>
   (const QID *qid);
</LI>
<LI>int <A href="smtdoc.htm#queue_destroy">queue destroy</A><BR>
   (QUEUE *queue);
</LI>
<LI>int <A href="smtdoc.htm#queue_flush">queue flush</A><BR>
   (QUEUE *queue);
</LI>
<LI>int <A href="smtdoc.htm#queue_deliver">queue deliver</A><BR>
   (QUEUE *queue, THREAD *thread);
</LI>
<LI>int <A href="smtdoc.htm#event_send">event send</A><BR>
   (const QID *to, const QID *from, char *name, byte *body, size_t
   body_size, char *accept, char *reject, char *expire, word
   timeout);
</LI>
<LI>EVENT * <A href="smtdoc.htm#event_accept">event accept</A><BR>
   (QUEUE *queue, EVENT *event);
</LI>
<LI>int <A href="smtdoc.htm#event_reject">event reject</A><BR>
   (QUEUE *queue, EVENT *event);
</LI>
<LI>int <A href="smtdoc.htm#event_expire">event expire</A><BR>
   (QUEUE *queue, EVENT *event);
</LI>
<LI>int <A href="smtdoc.htm#event_discard">event discard</A><BR>
   (QUEUE *queue, EVENT *event);
</LI>
<LI>EVENT * <A href="smtdoc.htm#event_iterate">event iterate</A><BR>
   (QUEUE *queue, EVENT *event);
</LI>
<LI>int <A href="smtdoc.htm#event_destroy">event destroy</A><BR>
   (EVENT *event);
</LI>
<LI>void <A href="smtdoc.htm#event_wait">event wait</A><BR>
   (void);
</LI>
<LI>THREAD * <A href="smtdoc.htm#thread_create">thread create</A><BR>
   (const char *agent, const char *thread);
</LI>
<LI>THREAD * <A href="smtdoc.htm#thread_lookup">thread lookup</A><BR>
   (const char *agent, const char *thread);
</LI>
<LI>int <A href="smtdoc.htm#thread_destroy">thread destroy</A><BR>
   (THREAD *thread, Bool cleanup);
</LI>
<LI>SEMAPH * <A href="smtdoc.htm#semaph_create">semaph create</A><BR>
   (const char *name, int value);
</LI>
<LI>SEMAPH * <A href="smtdoc.htm#semaph_lookup">semaph lookup</A><BR>
   (const char *name);
</LI>
<LI>int <A href="smtdoc.htm#semaph_destroy">semaph destroy</A><BR>
   (SEMAPH *semaph);
</LI>
<LI>int <A href="smtdoc.htm#semaph_wait">semaph wait</A><BR>
   (SEMAPH *semaph);
</LI>
<LI>int <A href="smtdoc.htm#semaph_signal">semaph signal</A><BR>
   (SEMAPH *semaph);
</LI>
<LI>int <A href="smtdoc.htm#lazy_creat">lazy creat</A><BR>
   (char *path, int mode);
</LI>
<LI>int <A href="smtdoc.htm#lazy_creat_text">lazy creat text</A><BR>
   (char *path, int mode);
</LI>
<LI>int <A href="smtdoc.htm#lazy_open">lazy open</A><BR>
   (char *path, int flags);
</LI>
<LI>int <A href="smtdoc.htm#lazy_open_text">lazy open text</A><BR>
   (char *path, int flags);
</LI>
<LI>int <A href="smtdoc.htm#lazy_read">lazy read</A><BR>
   (int handle, char *buffer, size_t count);
</LI>
<LI>int <A href="smtdoc.htm#lazy_write">lazy write</A><BR>
   (int handle, char *buffer, size_t count);
</LI>
<LI>int <A href="smtdoc.htm#lazy_close">lazy close</A><BR>
   (int handle);
</LI>
<LI>int <A href="smtdoc.htm#senderr">senderr</A><BR>
   (const QID *to_queue);
</LI>
<LI>int <A href="smtdoc.htm#sendfmt">sendfmt</A><BR>
   (const QID *to_queue, char *name, char *format,...);
</LI>
<LI>void <A href="smtdoc.htm#raise_exception">raise exception</A><BR>
   (event_t event);
</LI>
<LI>void <A href="smtdoc.htm#recycle_module">recycle module</A><BR>
   (Bool wanted);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>smtlib.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SEND(q,name,s)</B>  </TT>
<TD ALIGN="LEFT">event_send ((q), NULL, (name), (byte *) (s), <TR><TD ALIGN="LEFT"><TT><B>SMT_ACTION_STOP</B>  </TT>
<TD ALIGN="LEFT">0xFFFFL /* End of module list */
<TR><TD ALIGN="LEFT"><TT><B>SMT_AGENTEXISTS</B>  </TT>
<TD ALIGN="LEFT">15 /* Agent already declared */
<TR><TD ALIGN="LEFT"><TT><B>SMT_AGENTNOTREADY</B>  </TT>
<TD ALIGN="LEFT">16 /* Agent not initialised */
<TR><TD ALIGN="LEFT"><TT><B>SMT_AGENT_NORMAL</B>  </TT>
<TD ALIGN="LEFT">0 /* 1 queue for 1 thread */
<TR><TD ALIGN="LEFT"><TT><B>SMT_AGENT_ROUTER</B>  </TT>
<TD ALIGN="LEFT">1 /* 1 queue for n threads */
<TR><TD ALIGN="LEFT"><TT><B>SMT_EVENTEXISTS</B>  </TT>
<TD ALIGN="LEFT">1 /* Event already declared */
<TR><TD ALIGN="LEFT"><TT><B>SMT_INTERNALERROR</B>  </TT>
<TD ALIGN="LEFT">2 /* Agent had internal error */
<TR><TD ALIGN="LEFT"><TT><B>SMT_LOOP_DETECTION</B>  </TT>
<TD ALIGN="LEFT">2 /* After this, we abort */
<TR><TD ALIGN="LEFT"><TT><B>SMT_METHODEXISTS</B>  </TT>
<TD ALIGN="LEFT">3 /* Method already declared */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NOERRORS</B>  </TT>
<TD ALIGN="LEFT">0 /* No errors */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NOSUCHAGENT</B>  </TT>
<TD ALIGN="LEFT">8 /* Agent not defined */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NOSUCHEVENT</B>  </TT>
<TD ALIGN="LEFT">4 /* Unknown event name */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NOSUCHMETHOD</B>  </TT>
<TD ALIGN="LEFT">5 /* Unknown method name */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NOSUCHQUEUE</B>  </TT>
<TD ALIGN="LEFT">6 /* Event queue not defined */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NOSUCHSEMAPH</B>  </TT>
<TD ALIGN="LEFT">7 /* Unknown semaphore name */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NOSUCHTHREAD</B>  </TT>
<TD ALIGN="LEFT">9 /* Thread not declared */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NOTREADY</B>  </TT>
<TD ALIGN="LEFT">10 /* SMT API not initialised */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NULL_EVENT</B>  </TT>
<TD ALIGN="LEFT">-2 /* No event provided */
<TR><TD ALIGN="LEFT"><TT><B>SMT_NULL_STATE</B>  </TT>
<TD ALIGN="LEFT">-1 /* Thread not initialised */
<TR><TD ALIGN="LEFT"><TT><B>SMT_OUTOFMEMORY</B>  </TT>
<TD ALIGN="LEFT">11 /* Not enough heap memory left */
<TR><TD ALIGN="LEFT"><TT><B>SMT_PRIORITY_HIGH</B>  </TT>
<TD ALIGN="LEFT">200 /* High priority */
<TR><TD ALIGN="LEFT"><TT><B>SMT_PRIORITY_LOW</B>  </TT>
<TD ALIGN="LEFT">50 /* Low priority */
<TR><TD ALIGN="LEFT"><TT><B>SMT_PRIORITY_MAX</B>  </TT>
<TD ALIGN="LEFT">255 /* Highest priority */
<TR><TD ALIGN="LEFT"><TT><B>SMT_PRIORITY_MIN</B>  </TT>
<TD ALIGN="LEFT">1 /* Lowest priority */
<TR><TD ALIGN="LEFT"><TT><B>SMT_PRIORITY_NORMAL</B>  </TT>
<TD ALIGN="LEFT">100 /* Default priority */
<TR><TD ALIGN="LEFT"><TT><B>SMT_PRIORITY_NULL</B>  </TT>
<TD ALIGN="LEFT">0 /* Illegal (null) priority */
<TR><TD ALIGN="LEFT"><TT><B>SMT_QUEUEISEMPTY</B>  </TT>
<TD ALIGN="LEFT">12 /* Event queue is empty */
<TR><TD ALIGN="LEFT"><TT><B>SMT_QUEUEISFULL</B>  </TT>
<TD ALIGN="LEFT">13 /* Event queue is full */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SEMAPHEXISTS</B>  </TT>
<TD ALIGN="LEFT">14 /* Semaphore already exists */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SHUTDOWN</B>  </TT>
<TD ALIGN="LEFT">"w" /* Shutdown signal */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SIGNAL_ALRM</B>  </TT>
<TD ALIGN="LEFT">4 /* SIGALRM - timer signal */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SIGNAL_INT</B>  </TT>
<TD ALIGN="LEFT">1 /* SIGINT - interrupted */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SIGNAL_SEGV</B>  </TT>
<TD ALIGN="LEFT">3 /* SIGSEGV - segment violation */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SIGNAL_TERM</B>  </TT>
<TD ALIGN="LEFT">2 /* SIGTERM - cancelled */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SIGNAL_USER</B>  </TT>
<TD ALIGN="LEFT">5 /* User shutdown request */
<TR><TD ALIGN="LEFT"><TT><B>SMT_TERM_EVENT</B>  </TT>
<TD ALIGN="LEFT">-1 /* Terminate the thread */
<TR><TD ALIGN="LEFT"><TT><B>SMT_THREADEXISTS</B>  </TT>
<TD ALIGN="LEFT">17 /* Thread already declared */
<TR><TD ALIGN="LEFT"><TT><B>SMT_THREAD_ACTIVE</B>  </TT>
<TD ALIGN="LEFT">1 /* Active and executing */
<TR><TD ALIGN="LEFT"><TT><B>SMT_THREAD_PASSIVE</B>  </TT>
<TD ALIGN="LEFT">2 /* Passive, between states */
<TR><TD ALIGN="LEFT"><TT><B>SMT_THREAD_WAIT_EVENT</B>  </TT>
<TD ALIGN="LEFT">3 /* Waiting for an event */
<TR><TD ALIGN="LEFT"><TT><B>SMT_THREAD_WAIT_SEMAPH</B>  </TT>
<TD ALIGN="LEFT">4 /* Waiting for a semaphore */
<TR><TD ALIGN="LEFT"><TT><B>SMT_TOOMANYTHREADS</B>  </TT>
<TD ALIGN="LEFT">18 /* Too many threads */
<TR><TD ALIGN="LEFT"><TT><B>SMT_VERSION</B>  </TT>
<TD ALIGN="LEFT">"2.71" /* Main SMT version number */
<TR><TD ALIGN="LEFT"><TT><B>_SMTLIB_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<H4>List of Type Definitions</H4>
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Type name:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>AGENT</B>  </TT>
<TD ALIGN="LEFT">struct _AGENT
<TR><TD ALIGN="LEFT"><TT><B>EVENT</B>  </TT>
<TD ALIGN="LEFT">struct _EVENT
<TR><TD ALIGN="LEFT"><TT><B>HOOK</B>  </TT>
<TD ALIGN="LEFT">void () (THREAD *)
<TR><TD ALIGN="LEFT"><TT><B>METHOD</B>  </TT>
<TD ALIGN="LEFT">struct _METHOD
<TR><TD ALIGN="LEFT"><TT><B>QID</B>  </TT>
<TD ALIGN="LEFT">struct _QID
<TR><TD ALIGN="LEFT"><TT><B>QUEUE</B>  </TT>
<TD ALIGN="LEFT">struct _QUEUE
<TR><TD ALIGN="LEFT"><TT><B>SEMAPH</B>  </TT>
<TD ALIGN="LEFT">struct _SEMAPH
<TR><TD ALIGN="LEFT"><TT><B>THREAD</B>  </TT>
<TD ALIGN="LEFT">struct _THREAD
<TR><TD ALIGN="LEFT"><TT><B>event_t</B>  </TT>
<TD ALIGN="LEFT">short int
<TR><TD ALIGN="LEFT"><TT><B>state_t</B>  </TT>
<TD ALIGN="LEFT">short int
</TABLE>
<A NAME="smt_init">&nbsp;</A>
<H3><A NAME="TOC67"><TT>smt_init</TT></A></H3>
<PRE>
#include "smtlib.h"
int
smt_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT. Returns 0 if there were no errors. Else
   returns -1, after seting smt_errno to one of these values:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT
   OUTOFMEMORY</B>  <TD ALIGN="LEFT">Not enough heap memory left
   </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    int feedback = 0;
#if (defined (SMT_TRACE))
    trace ("smt_init");
#endif
    if (!smt_alive)
      {
        dict = sym_create_table ();
        if (dict == NULL)
          {
            smt_errno = SMT_OUTOFMEMORY;
            feedback = -1;
          }
        /*  Initialise list of agents                                        */
        node_reset (&amp;agents);

        /*  Initialise list of exit functions                                */
        node_reset (&amp;exitfcts);

        /*  Initialise list of semaphores                                    */
        node_reset (&amp;semaphs);

        /*  Initialise list of active threads                                */
        active_threads.left  = &amp;active_threads;
        active_threads.right = &amp;active_threads;
        cur_threads = 0;

        /*  Handle interrupt signals                                         */
        handle_signals ();

        /*  On some systems we get a 'broken pipe' when a connection fails   */
#       if defined (SIGPIPE)
        signal (SIGPIPE, SIG_IGN);
#       endif

        /*  We pass through handle_atexit() before closing-down              */
        atexit (handle_atexit);

        smt_alive = TRUE;               /*  SMT kernel is now active         */
      }
    return (feedback);
}
</PRE>
<A NAME="smt_term">&nbsp;</A>
<H3><A NAME="TOC68"><TT>smt_term</TT></A></H3>
<PRE>
#include "smtlib.h"
int
smt_term (void)
</PRE>
<H4>Synopsis</H4>
<P>Shuts-down the SMT. Destroys all agents, methods, queues,
   events, threads. Returns 0 if there were no errors, otherwise
   returns -1 and sets smt_errno to one of these values: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT OUTOFMEMORY</B>  <TD ALIGN="LEFT">Not
   enough heap memory left </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    EXITFCT *exitfct;                   /*  Exit function address            */

#if (defined (SMT_TRACE))
    trace ("smt_term");
#endif
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    FORLIST (exitfct, exitfcts)         /*  Execute all exit functions       */
        (*exitfct-&gt; handler) ();
    while (exitfcts.next != &amp;exitfcts)  /*  And free the memory              */
        node_destroy (exitfcts.next);

    <A href="smtdoc.htm#agent_destroy">agent destroy</A> (NULL);               /*  Free all agents                  */
    <A href="smtdoc.htm#semaph_destroy">semaph destroy</A> (NULL);              /*  Free all semaphores              */
    sym_delete_table (dict);

    smt_alive = FALSE;                  /*  SMT is now disactivated          */
    return (0);
}
</PRE>
<A NAME="smt_exec_full">&nbsp;</A>
<H3><A NAME="TOC69"><TT>smt_exec_full</TT></A></H3>
<PRE>
#include "smtlib.h"
int
smt_exec_full (void)
</PRE>
<H4>Synopsis</H4>
<P>Executes the current set of threads until there are no more
   active threads left, or events to deliver. At this point we say
   that the application has 'halted'. Returns 0.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("smt_exec_full");
#endif
    while (<A href="smtdoc.htm#smt_exec_step">smt exec step</A> ());
    return (0);
}
</PRE>
<A NAME="smt_exec_step">&nbsp;</A>
<H3><A NAME="TOC70"><TT>smt_exec_step</TT></A></H3>
<PRE>
#include "smtlib.h"
Bool
smt_exec_step (void)
</PRE>
<H4>Synopsis</H4>
<P>Rebuilds the active list, delivering any events possible, then
   executes the first thread in the active list. Returns TRUE so
   long as there is something happening; returns FALSE when the
   application has 'halted'.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("smt_exec_step");
#endif
    deliver_events ();                  /*  Rebuild active thread list       */
    if (<A href="smtdoc.htm#smt_active">smt active</A> ())                  /*    and execute first thread       */
      {                                 /*    if any is active               */
        if (execute_thread (active_threads.right))
            /*  Fatal-error action for a thread is simple: destroy it        */
            <A href="smtdoc.htm#thread_destroy">thread destroy</A> (active_threads.right, FALSE);
        return (TRUE);
      }
    else
        return (FALSE);
}
</PRE>
<A NAME="smt_active">&nbsp;</A>
<H3><A NAME="TOC71"><TT>smt_active</TT></A></H3>
<PRE>
#include "smtlib.h"
Bool
smt_active (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns TRUE if the SMT has active threads, else false.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("smt_active: %d", (active_threads.right != &amp;active_threads));
#endif
    return (active_threads.right != &amp;active_threads);
}
</PRE>
<A NAME="smt_set_console">&nbsp;</A>
<H3><A NAME="TOC72"><TT>smt_set_console</TT></A></H3>
<PRE>
#include "smtlib.h"
void
smt_set_console (const QID *qid)
</PRE>
<H4>Synopsis</H4>
<P>Tells the SMT kernel to send error events to the specified
   console queue. There can be just one console queue. If you do
   not specify a console queue, error events are discarded.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("smt_set_console");
#endif
    console = *qid;
}
</PRE>
<A NAME="smt_set_timer">&nbsp;</A>
<H3><A NAME="TOC73"><TT>smt_set_timer</TT></A></H3>
<PRE>
#include "smtlib.h"
void
smt_set_timer (const QID *qid)
</PRE>
<H4>Synopsis</H4>
<P>Tells the SMT kernel to send alarm events to the specified
   timer queue. There can be just one timer queue. If you do not
   specify a timer queue, timer events are discarded.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("smt_set_timer");
#endif
    timer = *qid;
}
</PRE>
<A NAME="smt_atexit">&nbsp;</A>
<H3><A NAME="TOC74"><TT>smt_atexit</TT></A></H3>
<PRE>
#include "smtlib.h"
int
smt_atexit (function handler)
</PRE>
<H4>Synopsis</H4>
<P>Registers a termination function. The function is defined as a
   void function without arguments. The termination functions are
   called in the order that they are declared. Multiple instances
   of the same function are ignored. Returns 0 if okay, -1 if
   there was an error. In the case of an error, sets smt_errno to
   one of: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT
   NOTREADY</B>  <TD ALIGN="LEFT">smt_init() was not called, or
   failed <TR><TD ALIGN="LEFT"><B>SMT OUTOFMEMORY</B>  <TD
   ALIGN="LEFT">Not enough heap memory left </TABLE> The kernel
   executes termination functions before destroying agents and
   other objects. Thus, termination functions can access the
   object symbol table ('lookup' functions), but not send or
   receive events.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    EXITFCT *exitfct;                   /*  Agent information block          */

#if (defined (SMT_TRACE))
    trace ("smt_atexit");
#endif
    ASSERT (handler);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    /*  Check that exit function is not already defined; if so, ignore it    */
    FORLIST (exitfct, exitfcts)
        if (exitfct-&gt; handler == handler)
            return (0);

    /*  Allocate an EXITFCT block and attach it to the exitfcts list         */
    exitfct = (EXITFCT *) node_create (exitfcts.prev, sizeof (EXITFCT));
    if (exitfct == NULL)
      {
        smt_errno = SMT_OUTOFMEMORY;
        return (-1);
      }
    exitfct-&gt; handler = handler;
    return (0);
}
</PRE>
<A NAME="smt_shutdown">&nbsp;</A>
<H3><A NAME="TOC75"><TT>smt_shutdown</TT></A></H3>
<PRE>
#include "smtlib.h"
void
smt_shutdown (void)
</PRE>
<H4>Synopsis</H4>
<P>Ends the current SMT application. Use this if you detect a
   fatal error in a thread. Sends a SHUTDOWN event to every
   thread, so halting the application.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    signal_raised = TRUE;               /*  Signal user shutdown signal      */
    signal_value  = SMT_SIGNAL_USER;    /*  Kernel takes it from here        */
}
</PRE>
<A NAME="agent_declare">&nbsp;</A>
<H3><A NAME="TOC76"><TT>agent_declare</TT></A></H3>
<PRE>
#include "smtlib.h"
AGENT *
agent_declare (
    const char *agent_name              /*  Name of agent to declare         */
)
</PRE>
<H4>Synopsis</H4>
<P>Declares a new agent. Typically you'll do this when you are
   initialising a agent. You must declare the agent before you can
   create queues, threads, or methods for that agent. The agent
   name is an arbitrary text, unique within the application.
   Returns the address of the created AGENT block. If there was an
   error, returns NULL and sets smt_errno to one of these values:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>
   <TD ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT OUTOFMEMORY</B>  <TD ALIGN="LEFT">Not
   enough heap memory left <TR><TD ALIGN="LEFT"><B>SMT
   AGENTEXISTS</B>  <TD ALIGN="LEFT">A agent with this name is
   already declared </TABLE> Agents and threads are stored in the
   dictionary as follows: a name is built of three parts:
   s~agent~[thread]. This name is the key into the dictionary and
   lets us find a agent, or thread by name. Then, all agents are
   chained into a linked list that is attached to the agents list.
   Each agent has a sublist of queues, and each queue has a
   sublist of threads. Each thread has a pointer to the parent
   queue respectively. This cross-linking lets us browse the list
   of agents/threads from any point. Names are always stored in
   lower-case. Sets agent priority to SMT_PRIORITY_NORMAL; sets
   router flag to FALSE, and max_threads to 0.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */
    AGENT   *agent;                     /*  Agent information block          */
    char    *full_name;                 /*  Full agent name                  */

#if (defined (SMT_TRACE))
    trace ("agent_declare: agent=%s", agent_name);
#endif
    ASSERT (agent_name);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    /*  Check that agent is not already declared                             */
    full_name = get_entity_name (agent_name, NULL);
    if (sym_lookup_symbol (dict, full_name))
      {
        smt_errno = SMT_AGENTEXISTS;
        return (NULL);
      }

    /*  Now create entry for the agent                                       */
    dict_entry = sym_create_symbol (dict, full_name, NULL);
    if (dict_entry == NULL)
      {
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Allocate an AGENT block and attach it to the agent list              */
    agent = (AGENT *) node_create (agents.prev, sizeof (AGENT));
    if (agent == NULL)
      {
        sym_delete_symbol (dict, dict_entry);
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Point the dictionary entry to the agent information block            */
    dict_entry-&gt; data = agent;

    /*  Now initialise the agent - all fields are already set to zero        */
    node_reset (&amp;agent-&gt; methods);
    node_reset (&amp;agent-&gt; queues);
    agent-&gt; symbol = dict_entry;
    agent-&gt; name    = mem_strdup (agent_name);

    /*  These fields must be set by the calling program                      */
    agent-&gt; tcb_size     = 0;           /*  Size of thread context block     */
    agent-&gt; maxevent     = 0;           /*  Number of events defined         */
    agent-&gt; maxmodule    = 0;           /*  Number of modules defined        */
    agent-&gt; maxstate     = 0;           /*  Number of states defined         */
    agent-&gt; initialise   = NULL;        /*  Initialise-the-thread            */
    agent-&gt; LR_nextst    = NULL;        /*  Next state table                 */
    agent-&gt; LR_action    = NULL;        /*  Action table                     */
    agent-&gt; LR_offset    = NULL;        /*  Vector offset table              */
    agent-&gt; LR_vector    = NULL;        /*  Vector table                     */
    agent-&gt; LR_module    = NULL;        /*  Module table                     */
    agent-&gt; LR_defaults = 0;            /*  Defaults state                   */

    /*  These fields may be changed by the calling program                   */
    agent-&gt; stack_size   = 0;           /*  Subdialog stack size (if reqd)   */
    agent-&gt; LR_mname     = NULL;        /*  Module name table (if animated)  */
    agent-&gt; LR_sname     = NULL;        /*  State name table (if animated)   */
    agent-&gt; LR_ename     = NULL;        /*  Event name table (if animated)   */
    agent-&gt; priority     = SMT_PRIORITY_NORMAL;
    agent-&gt; router       = FALSE;       /*  Agent acts as a router           */
    agent-&gt; animate      = FALSE;       /*  Agent animation enabled          */
    agent-&gt; max_threads = 0;            /*  Max. number of threads           */

    return (agent);
}
</PRE>
<A NAME="agent_lookup">&nbsp;</A>
<H3><A NAME="TOC77"><TT>agent_lookup</TT></A></H3>
<PRE>
#include "smtlib.h"
AGENT *
agent_lookup (
    const char *agent_name              /*  Name of agent to look for        */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks whether a specific agent exists; returns the address of
   the agent information block, or NULL if there was an error,
   setting smt_errno to one of these values: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT NOSUCHAGENT</B>  <TD ALIGN="LEFT">Specified
   agent was not declared </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */

#if (defined (SMT_TRACE))
    trace ("agent_lookup: agent=%s", agent_name);
#endif
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    dict_entry = sym_lookup_symbol (dict, get_entity_name (agent_name, NULL));
    if (dict_entry == NULL)
      {
         smt_errno = SMT_NOSUCHAGENT;
         return (NULL);
      }
    return (dict_entry-&gt; data);         /*  Return pointer to AGENT          */
}
</PRE>
<A NAME="agent_destroy">&nbsp;</A>
<H3><A NAME="TOC78"><TT>agent_destroy</TT></A></H3>
<PRE>
#include "smtlib.h"
int
agent_destroy (
    AGENT *agent                        /*  Agent to destroy; null = all     */
)
</PRE>
<H4>Synopsis</H4>
<P>Destroys the agent. Returns 0 when completed. The agent
   argument points to an agent block, or is null. If null, all
   agents are destroyed. Returns 0 when completed normally, else
   returns -1 and sets smt_errno to one of these values: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("agent_destroy: agent=%s", agent? agent-&gt; name: "ALL");
#endif
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    if (agent == NULL)                  /*  Destroy all agents if wanted     */
        while (agents.next != &amp;agents)
            <A href="smtdoc.htm#agent_destroy">agent destroy</A> (agents.next);
    else                                /*  Else destroy this agent          */
      {
        /*   Destroy all queues and methods declared for the agent           */
        while (agent-&gt; queues.next != &amp;agent-&gt; queues)
            <A href="smtdoc.htm#queue_destroy">queue destroy</A> (agent-&gt; queues.next);
        while (agent-&gt; methods.next != &amp;agent-&gt; methods)
            <A href="smtdoc.htm#method_destroy">method destroy</A> (agent-&gt; methods.next);

        /*  We have to be a little careful or sym_delete_symbol () will      */
        /*  try to release the symbol's data area; the data area points      */
        /*  to our node, which we want to release ourselves.                 */
        agent-&gt; symbol-&gt; data = NULL;
        sym_delete_symbol (dict, agent-&gt; symbol);

        /*  Now delete the agent                                             */
        mem_strfree (&amp;agent-&gt; name);    /*  First we take its name           */
        node_destroy (agent);           /*  ... then we take its life        */
      }
    return (0);
}
</PRE>
<A NAME="method_declare">&nbsp;</A>
<H3><A NAME="TOC79"><TT>method_declare</TT></A></H3>
<PRE>
#include "smtlib.h"
METHOD *
method_declare (
    AGENT *agent,                       /*  Create method in this agent      */
    const char *method_name,            /*  Name of method to declare        */
    event_t event_number,               /*  Method number from dialog        */
    int     priority                    /*  Priority for the method, or 0    */
)
</PRE>
<H4>Synopsis</H4>
<P>Declares a new method for an agent. All external events that an
   agent is prepared to method are declared as methods. The agent
   must already have been declared using <A href="smtdoc.htm#agent_declare">agent declare</A>(). The
   method name is an arbitrary text, unique within the agent. The
   event number is the number of the event assigned by the dialog
   code generator; if you specify the event number as
   SMT_NULL_EVENT, the method is ignored. This discards any
   incoming events with that name. The priority may be 0 (meaning
   normal priority), SMT_PRIORITY_LOW, SMT_PRIORITY_HIGH, or
   another suitable value. Returns the address of the created
   METHOD block. If there was an error, returns NULL and sets
   smt_errno to one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD ALIGN="LEFT">smt_init()
   was not called, or failed <TR><TD ALIGN="LEFT"><B>SMT
   OUTOFMEMORY</B>  <TD ALIGN="LEFT">Not enough heap memory left
   <TR><TD ALIGN="LEFT"><B>SMT NOSUCHAGENT</B>  <TD
   ALIGN="LEFT">Specified agent was not declared <TR><TD
   ALIGN="LEFT"><B>SMT METHODEXISTS</B>  <TD ALIGN="LEFT">Method
   is already declared </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */
    METHOD  *method;                    /*  Method information block         */
    char    *full_name;                 /*  Full method name                 */

#if (defined (SMT_TRACE))
    trace ("method_declare: agent=%s method=%s", agent-&gt; name, method_name);
#endif
    ASSERT (agent);
    ASSERT (method_name);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    /*  Check that method is not already declared                            */
    full_name = get_method_name (agent-&gt; name, method_name);
    if (sym_lookup_symbol (dict, full_name))
      {
        smt_errno = SMT_METHODEXISTS;
        return (NULL);
      }

    /*  Now create entry for the method                                      */
    dict_entry = sym_create_symbol (dict, full_name, NULL);
    if (dict_entry == NULL)
      {
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Allocate a METHOD block and attach it to the method list             */
    method = (METHOD *) node_create (&amp;agent-&gt; methods, sizeof (METHOD));
    if (method == NULL)
      {
        sym_delete_symbol (dict, dict_entry);
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Point the dictionary entry to the method information block           */
    dict_entry-&gt; data = method;

    /*  Now initialise the method - all fields are already set to zero       */
    method-&gt; symbol       = dict_entry;
    method-&gt; agent        = agent;
    method-&gt; name         = mem_strdup (method_name);
    method-&gt; priority     = priority? priority: SMT_PRIORITY_NORMAL;
    method-&gt; event_number = event_number;

    return (method);
}
</PRE>
<A NAME="method_lookup">&nbsp;</A>
<H3><A NAME="TOC80"><TT>method_lookup</TT></A></H3>
<PRE>
#include "smtlib.h"
METHOD *
method_lookup (
    const AGENT *agent,                 /*  Agent to look at                 */
    const char *method_name             /*  Name of method to look for       */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks whether a specific method exists; returns the address of
   the method information block, or NULL if there was an error,
   setting smt_errno to one of these values: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT NOSUCHMETHOD</B>  <TD
   ALIGN="LEFT">Specified method was not declared </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */
    char    *full_name;                 /*  Full agent/method name           */

#if (defined (SMT_TRACE))
    trace ("method_lookup: agent=%s", agent-&gt; name, method_name);
#endif
    ASSERT (agent);
    ASSERT (method_name);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    full_name  = get_method_name (agent-&gt; name, method_name);
    dict_entry = sym_lookup_symbol (dict, full_name);
    if (dict_entry == NULL)
      {
         smt_errno = SMT_NOSUCHMETHOD;
         return (NULL);
      }
    return (dict_entry-&gt; data);         /*  Return pointer to METHOD         */
}
</PRE>
<A NAME="method_destroy">&nbsp;</A>
<H3><A NAME="TOC81"><TT>method_destroy</TT></A></H3>
<PRE>
#include "smtlib.h"
int
method_destroy (
    METHOD *method                      /*  Method to destroy                */
)
</PRE>
<H4>Synopsis</H4>
<P>Destroys the method. Returns 0 when completed. In case of
   error, returns -1 and sets smt_errno to one of these values:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>
   <TD ALIGN="LEFT">smt_init() was not called, or failed </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("method_destroy: method=%s", method-&gt; name);
#endif
    ASSERT (method);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    /*  We have to be a little careful or sym_delete_symbol () will          */
    /*  try to release the symbol's data area; the data area points          */
    /*  to our node, which we want to release ourselves.                     */
    method-&gt; symbol-&gt; data = NULL;
    sym_delete_symbol (dict, method-&gt; symbol);

    /*  Delete the method                                                    */
    mem_strfree (&amp;method-&gt; name);
    node_destroy (method);
    return (0);
}
</PRE>
<A NAME="queue_create">&nbsp;</A>
<H3><A NAME="TOC82"><TT>queue_create</TT></A></H3>
<PRE>
#include "smtlib.h"
QUEUE *
queue_create (
    AGENT *agent,                       /*  Parent agent block, or null      */
    int    max_events                   /*  Max. events; 0 = no limit        */
)
</PRE>
<H4>Synopsis</H4>
<P>Creates an event queue, and returns a handle to the created
   queue. Event queues are unnamed but attached to a agent within
   an agent. Queue can also be 'floating', i.e. not attached to a
   agent. This is useful for foreign programs. If you specify a
   agent, the queue is attached to that agent. If the agent
   argument is null, the queue is left floating. You always refer
   to a queue using its address (within the owning process) or QID
   handle (within any process). The current implementation uses a
   linked list in heap memory, so QID handles are only valid
   within the process. Future implementations may use other types
   of shared memory including connections across a communications
   protocol. Returns a pointer to the created QUEUE block. In case
   of error, returns null and sets smt_errno to one of these
   values: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT
   NOTREADY</B>  <TD ALIGN="LEFT">smt_init() was not called, or
   failed <TR><TD ALIGN="LEFT"><B>SMT OUTOFMEMORY</B>  <TD
   ALIGN="LEFT">Not enough heap memory left </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    static
      long  top_id = 0;                 /*  We number queues from 1 up       */
    QID     qid;                        /*  Created queue                    */
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */
    QUEUE   *queue;                     /*  Queue information block          */

#if (defined (SMT_TRACE))
    trace ("queue_create: agent=%s", agent? agent-&gt; name: "&lt;none&gt;");
#endif
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    qid.node  = 0;                      /*  Queues are local for now         */
    qid.ident = ++top_id;               /*  First queue has id = 1           */
    dict_entry = sym_create_symbol (dict, get_queue_name (&amp;qid), NULL);
    if (dict_entry == NULL)
      {
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Allocate a QUEUE block and attach it to the queue list               */
    queue = (QUEUE *) node_create (agent? &amp;agent-&gt; queues: NULL,
                                   sizeof (QUEUE));
    if (queue == NULL)
      {
        sym_delete_symbol (dict, dict_entry);
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Point the dictionary entry to the queue information block            */
    dict_entry-&gt; data = queue;

    /*  Now initialise the queue info block fields and list heads            */
    node_reset (&amp;queue-&gt; events);
    node_reset (&amp;queue-&gt; threads);
    queue-&gt; symbol     = dict_entry;
    queue-&gt; agent      = agent;
    queue-&gt; qid        = qid;
    queue-&gt; max_events = max_events;
    queue-&gt; shutdown   = FALSE;
    return (queue);
}
</PRE>
<A NAME="queue_lookup">&nbsp;</A>
<H3><A NAME="TOC83"><TT>queue_lookup</TT></A></H3>
<PRE>
#include "smtlib.h"
QUEUE *
queue_lookup (
    const QID *qid                      /*  Queue to find                    */
)
</PRE>
<H4>Synopsis</H4>
<P>Returns a pointer to the queue information block for the
   specified queue handle. You can change the max_events field,
   but you should not change the other fields in the queue
   information block. In case of error, returns NULL and sets
   smt_errno to one of these values: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD ALIGN="LEFT">smt_init()
   was not called, or failed <TR><TD ALIGN="LEFT"><B>SMT
   NOSUCHQUEUE</B>  <TD ALIGN="LEFT">The event queue is not
   defined </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Queue entry in dictionary        */

#if (defined (SMT_TRACE))
    trace ("queue_lookup");
#endif
    ASSERT (qid);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    dict_entry = sym_lookup_symbol (dict, get_queue_name (qid));
    if (dict_entry)
        return (dict_entry-&gt; data);
    else
      {
        smt_errno = SMT_NOSUCHQUEUE;
        return (NULL);
      }
}
</PRE>
<A NAME="queue_destroy">&nbsp;</A>
<H3><A NAME="TOC84"><TT>queue_destroy</TT></A></H3>
<PRE>
#include "smtlib.h"
int
queue_destroy (
    QUEUE *queue                        /*  Queue to destroy                 */
)
</PRE>
<H4>Synopsis</H4>
<P>Deletes any events in the event queue and then destroys the
   queue and all its threads. Returns 0 when successfully
   completed. In case of error, returns -1 and sets smt_errno to
   one of these values: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD ALIGN="LEFT">smt_init()
   was not called, or failed <TR><TD ALIGN="LEFT"><B>SMT
   NOSUCHQUEUE</B>  <TD ALIGN="LEFT">The event queue is not
   defined </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("queue_destroy");
#endif
    ASSERT (queue);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    /*  Delete all events in the queue                                       */
    while (<A href="smtdoc.htm#event_discard">event discard</A> (queue, NULL) == 0);

    /*  Destroy all threads defined for the queue                            */
    while (queue-&gt; threads.next != &amp;queue-&gt; threads)
        <A href="smtdoc.htm#thread_destroy">thread destroy</A> (queue-&gt; threads.next, FALSE);

    /*  We have to be a little careful or sym_delete_symbol () will          */
    /*  try to release the symbol's data area; the data area points          */
    /*  to our node, which we want to release ourselves.                     */
    queue-&gt; symbol-&gt; data = NULL;
    sym_delete_symbol (dict, queue-&gt; symbol);

    /*  Now delete the queue itself                                          */
    node_destroy (queue);
    return (0);
}
</PRE>
<A NAME="queue_deliver">&nbsp;</A>
<H3><A NAME="TOC85"><TT>queue_deliver</TT></A></H3>
<PRE>
#include "smtlib.h"
int
queue_deliver (
    QUEUE  *queue,                      /*  Queue containing events          */
    THREAD *thread)                     /*  Agent thread to receive event    */
</PRE>
<H4>Synopsis</H4>
<P>Tries to deliver an event from a queue to an agent thread. The
   event, if deliverable, is removed from the queue and stored in
   the thread-&gt; event block. Returns 1 if an event was
   delivered, else 0.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Agent to receive event           */
    EVENT   *event;                     /*  Event information block          */
    EVENT   *deliver_event;             /*  Event to deliver                 */
    METHOD  *method;                    /*  Method information block         */
    int     top_priority;               /*  Highest event priority so far    */

#if (defined (SMT_TRACE))
    trace ("queue_deliver: thread=%s in %s", thread-&gt; name,
                                             thread-&gt; queue-&gt; agent-&gt; name);
#endif
    /*  Get event to deliver - find event with highest method priority       */
    top_priority  = -1;
    deliver_event = NULL;
    agent = thread-&gt; queue-&gt; agent;
    event = queue-&gt; events.next;
    while ((NODE *) event != &amp;queue-&gt; events)
      {
        if (event-&gt; priority == SMT_PRIORITY_NULL)
          {
            /*  Lookup method; if method is not declared, reject event      */
            method = <A href="smtdoc.htm#method_lookup">method lookup</A> (agent, event-&gt; name);
            if (method == NULL)
              {
                /*  Reject this event, but keep our place in the queue...   */
                <A href="smtdoc.htm#sendfmt">sendfmt</A> (&amp;console, "ERROR", "Event %s not declared by %s",
                         event-&gt; name, agent-&gt; name);
                event = event-&gt; next;
                <A href="smtdoc.htm#event_reject">event reject</A> (queue, event-&gt; prev);
                continue;
              }
            else
            /*  If null method, accept event but discard it                 */
            if (method-&gt; event_number == SMT_NULL_EVENT)
              {
                event = event-&gt; next;
                node_destroy (<A href="smtdoc.htm#event_accept">event accept</A> (queue, event-&gt; prev));
                continue;
              }
            /*  Update the event values, to save a lookup next time         */
            event-&gt; priority     = method-&gt; priority;
            event-&gt; event_number = method-&gt; event_number;
          }
        if (event-&gt; priority &gt; top_priority)
          {
            top_priority  = event-&gt; priority;
            deliver_event = event;
          }
        event = event-&gt; next;
      }
    if (deliver_event)
      {
        /*  Deliver event to thread                                          */
        if (thread-&gt; event)
            <A href="smtdoc.htm#event_destroy">event destroy</A> (thread-&gt; event);
        thread-&gt; the_next_event = deliver_event-&gt; event_number;
        thread-&gt; event = <A href="smtdoc.htm#event_accept">event accept</A> (queue, deliver_event);
        return (1);                     /*  We delivered the event           */
      }
    else
        return (0);                     /*  We did not find an event         */
}
</PRE>
<A NAME="queue_flush">&nbsp;</A>
<H3><A NAME="TOC86"><TT>queue_flush</TT></A></H3>
<PRE>
#include "smtlib.h"
int
queue_flush (
    QUEUE *queue                        /*  Queue to flush                   */
)
</PRE>
<H4>Synopsis</H4>
<P>Expires any out-of-date events in the queue: calls
   <A href="smtdoc.htm#event_expire">event expire</A>() for each event who's timeout has passed.
   Returns the number of events expired. In case of error, returns
   -1 and sets smt_errno to one of these values: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT NOSUCHQUEUE</B>  <TD ALIGN="LEFT">The event
   queue is not defined </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    time_t  time_now;                   /*  Current time                     */
    int     feedback = 0;               /*  Number of events we delivered    */
    EVENT   *event;                     /*  Event information block          */

#if (defined (SMT_TRACE))
    trace ("queue_flush");
#endif
    ASSERT (queue);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    time_now = time (NULL);
    FORLIST (event, queue-&gt; events)
        if (event-&gt; timeout &amp;&amp; event-&gt; timeout &lt; time_now)
          {
            <A href="smtdoc.htm#event_expire">event expire</A> (queue, event);
            feedback++;
          }

    return (feedback);
}
</PRE>
<A NAME="event_send">&nbsp;</A>
<H3><A NAME="TOC87"><TT>event_send</TT></A></H3>
<PRE>
#include "smtlib.h"
int
event_send (
    const QID *to_queue,                /*  Queue to receive event, or NULL  */
    const QID *from_queue,              /*  Queue to receive reply, or NULL  */
    char   *name,                       /*  Name of event to send            */
    byte   *body,                       /*  Body of message or NULL          */
    size_t  body_size,                  /*  Size of body >= 0                */
    char   *accept_event,               /*  Accept event or NULL             */
    char   *reject_event,               /*  Reject event or NULL             */
    char   *expire_event,               /*  Expire event or NULL             */
    word    timeout                     /*  Timeout in seconds: 0 = none     */
)
</PRE>
<H4>Synopsis</H4>
<P>Sends an event to an event queue. The event body - if not null
   or empty - is always copied, crossing memory boundaries. The
   accept_event, reject_event, and timeout_events are sent back to
   the sender event queue as required. These events may be
   specified as null or empty strings. The timeout may be 0 for
   none, or a value in milliseconds. Returns 0 when successfully
   completed. The current implementation provides timeouts
   accurate to a second only. The target queue may be null, in
   which case the event is ignored, and not sent. This lets you
   reply to an event without always checking that the reply queue
   was specified. The event name and reply event names are always
   stored in uppercase. In case of error, returns -1 and sets
   smt_errno to one of these values: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD ALIGN="LEFT">smt_init()
   was not called, or failed <TR><TD ALIGN="LEFT"><B>SMT
   OUTOFMEMORY</B>  <TD ALIGN="LEFT">Not enough heap memory left
   <TR><TD ALIGN="LEFT"><B>SMT NOSUCHQUEUE</B>  <TD
   ALIGN="LEFT">The target event queue is not known <TR><TD
   ALIGN="LEFT"><B>SMT QUEUEISFULL</B>  <TD ALIGN="LEFT">The
   target event queue is full </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    static QID
        null_queue = {0, 0};            /*  Indicates a null sender queue    */
    QUEUE   *queue;                     /*  Queue where we will place event  */
    EVENT   *event;                     /*  Allocated event block            */
    size_t  size;                       /*  Total size of event block        */
    char    *string;                    /*  For storing event strings        */

#if (defined (SMT_TRACE))
    trace ("event_send: event=%s", name);
#endif
    ASSERT (name &amp;&amp; name [0]);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    /*  If the called did not specify a target queue, ignore                 */
    if (to_queue == NULL || to_queue-&gt; ident == 0)
        return (0);

    if (from_queue == NULL)             /*  If the caller did not specify    */
      {                                 /*    a reply queue, then we can     */
        accept_event =                  /*    ignore the reply events in     */
        reject_event =                  /*    any case.                      */
        expire_event = NULL;
        from_queue   = &amp;null_queue;
      }
    if ((queue = <A href="smtdoc.htm#queue_lookup">queue lookup</A> (to_queue)) == NULL)
      {
        smt_errno = SMT_NOSUCHQUEUE;
        return (-1);
      }

    /*  Check that we're allowed to create a new event                       */
    if (queue-&gt; max_events &gt; 0
    &amp;&amp;  queue-&gt; max_events == queue-&gt; cur_events)
      {
        smt_errno = SMT_QUEUEISFULL;
        return (-1);
      }

    /*  We allocate the event, body, and return events as a single           */
    /*  block, to reduce access to the heap and make cleaning-up easier.     */
    size = sizeof (EVENT) + body_size + strlen (name) + 1;
    if (accept_event)
        size += strlen (accept_event) + 1;
    if (reject_event)
        size += strlen (reject_event) + 1;
    if (expire_event)
        size += strlen (expire_event) + 1;

    /*  Allocate an EVENT block and attach it to the event list              */
    event = (EVENT *) node_create (queue-&gt; events.prev, size);
    if (event == NULL)
      {
        smt_errno = SMT_OUTOFMEMORY;
        return (-1);
      }

    event-&gt; priority  = SMT_PRIORITY_NULL;
    event-&gt; size      = size;           /*  Event is self-contained          */
    event-&gt; queue     = queue;          /*  Set parent queue address         */
    event-&gt; sender    = *from_queue;    /*    and sender queue               */
    event-&gt; body_size = body_size;      /*  Store body size                  */
    event-&gt; timeout   = timeout? time (NULL) + timeout: 0;

    /*  Store variable-length parts after main event structure               */
    string = (char *) event + sizeof (EVENT);
    event-&gt; name = string;
    strcpy (string, name);
    strupc (string);
    string += strlen (string) + 1;

    if (body_size &gt; 0)
      {
        /*  Store event body                                                 */
        event-&gt; body = (byte *) string;
        memcpy (string, body, body_size);
        string += body_size;
      }
    else
        event-&gt; body = NULL;

    if (accept_event)
      {
        event-&gt; accept_event = string;
        strcpy (string, accept_event);
        strupc (string);
        string += strlen (string) + 1;
      }
    else
        event-&gt; accept_event = NULL;

    if (reject_event)
      {
        event-&gt; reject_event = string;
        strcpy (string, reject_event);
        strupc (string);
        string += strlen (string) + 1;
      }
    else
        event-&gt; reject_event = NULL;

    if (expire_event)
      {
        event-&gt; expire_event = string;
        strcpy (string, expire_event);
        strupc (string);
        string += strlen (string) + 1;
      }
    else
        event-&gt; expire_event = NULL;

    if (timeout)
        queue-&gt; timed_events++;         /*  Count event if timed             */
    queue-&gt; cur_events++;               /*  Count the event                  */
    return (0);                         /*  No errors                        */
}
</PRE>
<A NAME="event_accept">&nbsp;</A>
<H3><A NAME="TOC88"><TT>event_accept</TT></A></H3>
<PRE>
#include "smtlib.h"
EVENT *
event_accept (
    QUEUE *queue,                       /*  Queue to take event from         */
    EVENT *event                        /*  Event, or null for first         */
)
</PRE>
<H4>Synopsis</H4>
<P>Takes an event off an event queue, and sends an 'accept' reply
   to the original sender, if required. If the specified event is
   null, takes the first (oldest) event in the queue. Otherwise
   takes the specified event. Returns the address of the event.
   You should call <A href="smtdoc.htm#event_destroy">event destroy</A>() when you have finished
   processing the event. In case of error, returns NULL and sets
   smt_errno to one of these values: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD ALIGN="LEFT">smt_init()
   was not called, or failed <TR><TD ALIGN="LEFT"><B>SMT
   QUEUEISEMPTY</B>  <TD ALIGN="LEFT">The queue was empty </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("event_accept");
#endif
    ASSERT (queue);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    if ((event = event_locate (queue, event)) == NULL)
        return (NULL);

    /*  Reply to original sender if necessary                                */
    if (event-&gt; accept_event)
        <A href="smtdoc.htm#event_send">event send</A> (
            &amp;event-&gt; sender,            /*  Send back to original sender     */
            NULL,                       /*  No queue for reply               */
            event-&gt; accept_event,       /*  Name of event to send            */
            NULL, 0,                    /*  Body is empty, size is 0         */
            NULL, NULL, NULL,           /*  No response events               */
            0);                         /*  No timeout                       */

    if (event-&gt; timeout)
        queue-&gt; timed_events++;         /*  One less timed event, maybe      */
    queue-&gt; cur_events--;               /*  One less event in queue          */

    node_unlink (event);                /*  Unlink from queue                */
    return (event);
}
</PRE>
<A NAME="event_reject">&nbsp;</A>
<H3><A NAME="TOC89"><TT>event_reject</TT></A></H3>
<PRE>
#include "smtlib.h"
int
event_reject (
    QUEUE *queue,                       /*  Queue to take event from         */
    EVENT *event                        /*  Event, or null for first         */
)
</PRE>
<H4>Synopsis</H4>
<P>Rejects the next event or a specific event on an event queue.
   Sends a 'rejected' event to the original sender if required,
   then destroys the event. You can use this to reject one
   specific message, or in a loop to cancel the entire queue.
   Returns 0 if the event was successfully rejected, else returns
   -1 and sets smt_errno to one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD ALIGN="LEFT">smt_init()
   was not called, or failed <TR><TD ALIGN="LEFT"><B>SMT
   QUEUEISEMPTY</B>  <TD ALIGN="LEFT">The queue was empty </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("event_reject");
#endif
    ASSERT (queue);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    if ((event = event_locate (queue, event)) == NULL)
        return (-1);

    /*  Reply to original sender if necessary                                */
    if (event-&gt; reject_event)
        <A href="smtdoc.htm#event_send">event send</A> (
            &amp;event-&gt; sender,            /*  Send back to original sender     */
            NULL,                       /*  No queue for reply               */
            event-&gt; reject_event,       /*  Name of event to send            */
            NULL, 0,                    /*  Body is empty, size is 0         */
            NULL, NULL, NULL,           /*  No response events               */
            0);                         /*  No timeout                       */

    /*  Unlink and destroy event                                             */
    return (<A href="smtdoc.htm#event_discard">event discard</A> (queue, event));
}
</PRE>
<A NAME="event_expire">&nbsp;</A>
<H3><A NAME="TOC90"><TT>event_expire</TT></A></H3>
<PRE>
#include "smtlib.h"
int
event_expire (
    QUEUE *queue,                       /*  Queue to take event from         */
    EVENT *event                        /*  Event, or null for first         */
)
</PRE>
<H4>Synopsis</H4>
<P>Expires the next event or a specific event on an event queue.
   Sends a 'expired' event to the original sender if required,
   then destroys the event. You can use this to expire one
   specific message, or in a loop to cancel the entire queue.
   Returns 0 if the event was successfully expired, else returns -
   1 and sets smt_errno to one of: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD ALIGN="LEFT">smt_init()
   was not called, or failed <TR><TD ALIGN="LEFT"><B>SMT
   QUEUEISEMPTY</B>  <TD ALIGN="LEFT">The queue was empty </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("event_expire");
#endif
    ASSERT (queue);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    if ((event = event_locate (queue, event)) == NULL)
        return (-1);

    /*  Reply to original sender if necessary                                */
    if (event-&gt; expire_event)
        <A href="smtdoc.htm#event_send">event send</A> (
            &amp;event-&gt; sender,            /*  Send back to original sender     */
            NULL,                       /*  No queue for reply               */
            event-&gt; expire_event,       /*  Name of event to send            */
            NULL, 0,                    /*  Body is empty, size is 0         */
            NULL, NULL, NULL,           /*  No response events               */
            0);                         /*  No timeout                       */

    /*  Unlink and destroy event                                             */
    return (<A href="smtdoc.htm#event_discard">event discard</A> (queue, event));
}
</PRE>
<A NAME="event_discard">&nbsp;</A>
<H3><A NAME="TOC91"><TT>event_discard</TT></A></H3>
<PRE>
#include "smtlib.h"
int
event_discard (
    QUEUE *queue,                       /*  Queue to take event from         */
    EVENT *event                        /*  Event, or null                   */
)
</PRE>
<H4>Synopsis</H4>
<P>Discards the specified event in the specified queue. The
   <A href="smtdoc.htm#event_iterate">event iterate</A> (), <A href="smtdoc.htm#event_accept">event accept</A> () and <A href="smtdoc.htm#event_discard">event discard</A>
   () calls let a thread manipulate its event queue directly. In
   such cases the thread takes responsibility for event delivery
   and acknowledgement. Returns 0 when successfully completed. In
   case of error, returns -1 and sets smt_errno to one of these
   values: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT
   NOTREADY</B>  <TD ALIGN="LEFT">smt_init() was not called, or
   failed <TR><TD ALIGN="LEFT"><B>SMT QUEUEISEMPTY</B>  <TD
   ALIGN="LEFT">The queue was empty </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("event_discard");
#endif
    ASSERT (queue);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    if ((event = event_locate (queue, event)) == NULL)
        return (-1);

    queue-&gt; cur_events--;               /*  Count the event                  */
    <A href="smtdoc.htm#event_destroy">event destroy</A> (event);              /*  Unlink and destroy event         */
    return (0);
}
</PRE>
<A NAME="event_iterate">&nbsp;</A>
<H3><A NAME="TOC92"><TT>event_iterate</TT></A></H3>
<PRE>
#include "smtlib.h"
EVENT *
event_iterate (
    QUEUE *queue,                       /*  Queue to search                  */
    EVENT *event                        /*  Event, or null for first         */
)
</PRE>
<H4>Synopsis</H4>
<P>Returns the first or next event in the queue. If the 'after'
   argument is null, returns the first event, else returns the
   next event. You should not 'walk' the event queue directly,
   since the implementation may change arbitrarily. Returns a
   pointer to the next event, or null if no (further) events were
   found. May set smt_errno to one of: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT QUEUEISEMPTY</B>  <TD ALIGN="LEFT">The
   queue was empty </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("event_iterate");
#endif
    ASSERT (queue);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    /*  If no event specified, get first event in queue                      */
    if (event == NULL)
        event = (EVENT *) &amp;queue-&gt; events;

    event = event-&gt; next;               /*  Get next event in queue          */
    if (event == (EVENT *) &amp;queue-&gt; events)
      {
        smt_errno = SMT_QUEUEISEMPTY;
        return (NULL);
      }
    return (event);
}
</PRE>
<A NAME="event_destroy">&nbsp;</A>
<H3><A NAME="TOC93"><TT>event_destroy</TT></A></H3>
<PRE>
#include "smtlib.h"
int
event_destroy (
    EVENT *event                        /*  Event block to destroy           */
)
</PRE>
<H4>Synopsis</H4>
<P>Destroys the specified event, which is assumed not to be linked
   into any queue. Typically you'll call this after processing an
   event you received with <A href="smtdoc.htm#event_accept">event accept</A>(). Returns 0 if okay.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("event_destroy: event=%s", event-&gt; name);
#endif
    node_destroy (event);               /*  Unlink and destroy event         */
    return (0);
}
</PRE>
<A NAME="event_wait">&nbsp;</A>
<H3><A NAME="TOC94"><TT>event_wait</TT></A></H3>
<PRE>
#include "smtlib.h"
void
event_wait (void)
</PRE>
<H4>Synopsis</H4>
<P>Suspends processing of an action module list, and waits for an
   incoming event. The event is received in 'the_external_event'
   by the next dialog module. When called in the last module in a
   list, has no effect. This call has no effect if you raise an
   exception or supply a value in the_next_event.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("event_wait");
#endif
    break_wanted = BREAK_WAIT_EVENT;
}
</PRE>
<A NAME="thread_create">&nbsp;</A>
<H3><A NAME="TOC95"><TT>thread_create</TT></A></H3>
<PRE>
#include "smtlib.h"
THREAD *
thread_create (
    const char *agent_name,             /*  Name of agent                    */
    const char *thread_name             /*  Create thread with this name     */
)
</PRE>
<H4>Synopsis</H4>
<P>Creates a new thread, and possibly an event queue for the
   thread. The caller specifies the agent and thread name. The
   agent must already be declared using <A href="smtdoc.htm#agent_declare">agent declare</A>(). If
   the agent was defined as a router, you can create multiple
   threads with the same name. These threads then share the same
   event queue on an anonymous basis. If the agent was not defined
   as a router, it is illegal to create multiple threads with the
   same name unless the name is empty (meaning "" or NULL). The
   function automatically creates an event queue for the thread
   when required. Returns a pointer to the created THREAD block,
   or null if there was an error. In that case, sets smt_errno to
   one of: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT
   NOTREADY</B>  <TD ALIGN="LEFT">smt_init() was not called, or
   failed <TR><TD ALIGN="LEFT"><B>SMT OUTOFMEMORY</B>  <TD
   ALIGN="LEFT">Not enough heap memory left <TR><TD
   ALIGN="LEFT"><B>SMT NOSUCHAGENT</B>  <TD ALIGN="LEFT">The agent
   was not declared <TR><TD ALIGN="LEFT"><B>SMT AGENTNOTREADY</B>
   <TD ALIGN="LEFT">The agent is not initialised <TR><TD
   ALIGN="LEFT"><B>SMT TOOMANYTHREADS</B>  <TD ALIGN="LEFT">Tried
   to exceed the maximum permitted threads <TR><TD
   ALIGN="LEFT"><B>SMT THREADEXISTS</B>  <TD ALIGN="LEFT">The
   thread already exists </TABLE> Attaches the thread to the
   active thread list.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */
    AGENT   *agent;                     /*  Agent information block          */
    QUEUE   *queue;                     /*  Queue information block          */
    THREAD  *thread;                    /*  Created thread block             */
    char    *full_name;                 /*  Full thread name                 */

#if (defined (SMT_TRACE))
    trace ("thread_create: agent=%s thread=%s", agent_name, thread_name);
#endif
    ASSERT (agent_name);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    /*  Find agent, quit if there was an error                               */
    if ((agent = <A href="smtdoc.htm#agent_lookup">agent lookup</A> (agent_name)) == NULL)
        return (NULL);

    /*  Check that we're allowed to create a new thread                      */
    if (agent-&gt; max_threads &gt; 0
    &amp;&amp;  agent-&gt; max_threads == agent-&gt; cur_threads)
      {
        smt_errno = SMT_TOOMANYTHREADS;
        return (NULL);
      }

    /*  Simple check that agent has been initialised                         */
    if (agent-&gt; initialise == NULL)
      {
        smt_errno = SMT_AGENTNOTREADY;
        return (NULL);
      }

    /*  Treat a NULL thread name as an empty string                          */
    if (thread_name == NULL)
        thread_name = "";

    /*  Check if the thread already exists                                   */
    full_name  = get_entity_name (agent_name, thread_name);
    dict_entry = sym_lookup_symbol (dict, full_name);
    queue      = NULL;                  /*  No queue created yet             */
    if (dict_entry)
      {
        /*  If it's a router, we'll use the same queue                       */
        if (agent-&gt; router)
            queue = ((THREAD *) (dict_entry-&gt; data))-&gt; queue;
        else
        if (thread_name [0])            /*  Otherwise it's an error if the   */
          {                             /*    thread was given a name        */
            smt_errno = SMT_THREADEXISTS;
            return (NULL);
          }
      }
    if (!queue)                        /*   Create new queue in agent        */
        queue = <A href="smtdoc.htm#queue_create">queue create</A> (agent, 0);

    /*  Now create entry for the thread                                      */
    dict_entry = sym_create_symbol (dict, full_name, NULL);
    if (dict_entry == NULL)
      {
        if (queue)                      /*  Clean-up nicely                  */
            <A href="smtdoc.htm#queue_destroy">queue destroy</A> (queue);
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Allocate a THREAD block and attach it to the queue's thread list     */
    /*  We also allocate the TCB and subdialog stack if that is required     */
    thread = (THREAD *) node_create (&amp;queue-&gt; threads, sizeof (THREAD));
    if (thread)
      {
        thread-&gt; tcb      = agent-&gt; tcb_size &gt; 0?
                            mem_alloc (agent-&gt; tcb_size):
                            NULL;
        thread-&gt; LR_stack = agent-&gt; stack_size &gt; 0?
                            mem_alloc (agent-&gt; stack_size * sizeof (event_t)):
                            NULL;
      }
    if (thread == NULL)
      {
        sym_delete_symbol (dict, dict_entry);
        if (queue)                      /*  Clean-up nicely                  */
            <A href="smtdoc.htm#queue_destroy">queue destroy</A> (queue);
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Point the dictionary entry to the thread information block            */
    dict_entry-&gt; data = thread;

    /*  Now initialise the thread fields and list heads                       */
    thread-&gt; symbol     = dict_entry;
    thread-&gt; name       = mem_strdup (thread_name);
    thread-&gt; queue      = queue;
    thread-&gt; thread_id  = agent-&gt; thread_tally++;
    thread-&gt; animate    = agent-&gt; animate;
    thread-&gt; left       = thread;
    thread-&gt; right      = thread;
    thread-&gt; event      = NULL;         /*  Last event for thread            */

    cur_threads++;                      /*  Keep count of threads            */
    agent-&gt; cur_threads++;
    if (agent-&gt; top_threads &lt; agent-&gt; cur_threads)
        agent-&gt; top_threads = agent-&gt; cur_threads;

    activate_thread (thread);           /*  Move thread to active list       */
    thread-&gt; state    = SMT_THREAD_ACTIVE;
    thread-&gt; LR_state = SMT_NULL_STATE;
    return (thread);
}
</PRE>
<A NAME="thread_lookup">&nbsp;</A>
<H3><A NAME="TOC96"><TT>thread_lookup</TT></A></H3>
<PRE>
#include "smtlib.h"
THREAD *
thread_lookup (
    const char *agent_name,             /*  Name of agent                    */
    const char *thread_name             /*  Create thread with this name     */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks whether a specific thread exists; returns the address of
   the thread information block, or NULL if there was an error,
   setting smt_errno to one of these values: <TABLE BORDER NOWRAP>
   <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT NOSUCHTHREAD</B>  <TD ALIGN="LEFT">The
   agent/thread does not exist </TABLE> If there are multiple
   threads (routers) with the same name, returns the earliest
   thread that was defined.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */
    char    *full_name;                 /*  Full thread name                 */

#if (defined (SMT_TRACE))
    trace ("thread_lookup: agent=%s thread=%s", agent_name, thread_name);
#endif
    ASSERT (agent_name);
    ASSERT (thread_name);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    /*  Check if the thread already exists                                   */
    full_name  = get_entity_name (agent_name, thread_name);
    dict_entry = sym_lookup_symbol (dict, full_name);
    if (dict_entry == NULL)
      {
         smt_errno = SMT_NOSUCHTHREAD;
         return (NULL);
      }

    /*  Get address of thread block, then find first thread defined for      */
    /*  this queue.  Usually it will be the same thread; when there are      */
    /*  multiple threads (routers) it may be a different thread.             */
    return (((THREAD *) (dict_entry-&gt; data))-&gt; queue-&gt; threads.next);
}
</PRE>
<A NAME="thread_destroy">&nbsp;</A>
<H3><A NAME="TOC97"><TT>thread_destroy</TT></A></H3>
<PRE>
#include "smtlib.h"
int
thread_destroy (
    THREAD *thread,                     /*  Thread to destroy                */
    Bool    cleanup                     /*  Delete queue if last thread      */
)
</PRE>
<H4>Synopsis</H4>
<P>Destroys the thread. If this was the last instance of a router
   thread, destroys the parent queue as well, if the cleanup
   argument is TRUE. Returns 0 if successfully completed, else
   returns -1 and sets smt_errno to one of these values: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed </TABLE>
   Removes the thread from the active list if it was attached
   there. Destroys any event allocated for the thread.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Agent information block          */
    QUEUE   *queue;                     /*  Queue information block          */

#if (defined (SMT_TRACE))
    trace ("thread_destroy: thread=%s", thread-&gt; name);
#endif
    ASSERT (thread);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    queue = thread-&gt; queue;             /*  Get parents for thread           */
    agent = queue-&gt; agent;

    /*  We have to be a little careful or sym_delete_symbol () will          */
    /*  try to release the symbol's data area; the data area points          */
    /*  to our node, which we want to release ourselves.                     */
    thread-&gt; symbol-&gt; data = NULL;
    sym_delete_symbol (dict, thread-&gt; symbol);

    /*  Destroy event for the thread, if we still need to                    */
    if (thread-&gt; event)                 /*  NULL = no event for thread       */
        <A href="smtdoc.htm#event_destroy">event destroy</A> (thread-&gt; event);

    /*  Delete the thread                                                    */
    thread_unlink (thread);             /*  Remove thread from active        */
    mem_free (thread-&gt; tcb);            /*  Free allocated TCB,              */
    mem_free (thread-&gt; LR_stack);       /*    and sub-dialog stack           */
    mem_strfree (&amp;thread-&gt; name);
    node_destroy (thread);

    /*  Destroy queue if last thread, and we are asked to clean-up           */
    if (queue-&gt; threads.next == &amp;queue-&gt; threads &amp;&amp; cleanup)
        <A href="smtdoc.htm#queue_destroy">queue destroy</A> (queue);

    ASSERT (agent-&gt; cur_threads &gt; 0);
    agent-&gt; cur_threads--;
    cur_threads--;                      /*  Keep count of threads            */
    return (0);
}
</PRE>
<A NAME="semaph_create">&nbsp;</A>
<H3><A NAME="TOC98"><TT>semaph_create</TT></A></H3>
<PRE>
#include "smtlib.h"
SEMAPH *
semaph_create (
    const char *semaph_name,            /*  Name of semaph to create         */
    int   value                         /*  Initial semaphore value          */
)
</PRE>
<H4>Synopsis</H4>
<P>Creates a new semaphore. You must create a semaphore before you
   can use it. The value argument specifies the number of parties
   that can access the semaphore (or its related resources) at
   once. The value must be greated than zero. A 'normal' binary
   semaphore has an initial value of 1. The semaph name is an
   arbitrary text, unique within the application. Returns the
   address of the created SEMAPH block. If there was an error,
   returns NULL and sets smt_errno to one of these values: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT OUTOFMEMORY</B>  <TD ALIGN="LEFT">Not
   enough heap memory left <TR><TD ALIGN="LEFT"><B>SMT
   SEMAPHEXISTS</B>  <TD ALIGN="LEFT">A semaphore with this name
   is already declared </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */
    SEMAPH  *semaph;                    /*  Agent information block          */
    char    *full_name;                 /*  Full semaph name                 */

#if (defined (SMT_TRACE))
    trace ("semaph_create: semaph=%s", semaph_name);
#endif
    ASSERT (semaph_name);
    ASSERT (value &gt; 0);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    /*  Check that semaphore is not already declared                         */
    full_name = get_semaph_name (semaph_name);
    if (sym_lookup_symbol (dict, full_name))
      {
        smt_errno = SMT_SEMAPHEXISTS;
        return (NULL);
      }

    /*  Now create entry for the semaphore                                   */
    dict_entry = sym_create_symbol (dict, full_name, NULL);
    if (dict_entry == NULL)
      {
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Allocate an SEMAPH block and attach it to the semaphore list         */
    semaph = (SEMAPH *) node_create (semaphs.prev, sizeof (SEMAPH));
    if (semaph == NULL)
      {
        sym_delete_symbol (dict, dict_entry);
        smt_errno = SMT_OUTOFMEMORY;
        return (NULL);
      }

    /*  Point the dictionary entry to the semaph information block           */
    dict_entry-&gt; data = semaph;

    /*  Now initialise the semaph - all fields are already set to zero       */
    semaph-&gt; symbol        = dict_entry;
    semaph-&gt; name          = mem_strdup (semaph_name);
    semaph-&gt; threads.left  = &amp;semaph-&gt; threads;
    semaph-&gt; threads.right = &amp;semaph-&gt; threads;
    semaph-&gt; value         = value;

    return (semaph);
}
</PRE>
<A NAME="semaph_lookup">&nbsp;</A>
<H3><A NAME="TOC99"><TT>semaph_lookup</TT></A></H3>
<PRE>
#include "smtlib.h"
SEMAPH *
semaph_lookup (
    const char *semaph_name             /*  Name of semaph to look for       */
)
</PRE>
<H4>Synopsis</H4>
<P>Checks whether a specific semaphore exists; returns the address
   of the semaphore information block, or NULL if there was an
   error, setting smt_errno to one of these values: <TABLE BORDER
   NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>  <TD
   ALIGN="LEFT">smt_init() was not called, or failed <TR><TD
   ALIGN="LEFT"><B>SMT NOSUCHSEMAPH</B>  <TD
   ALIGN="LEFT">Specified semaphore was not declared </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    SYMBOL  *dict_entry;                /*  Dictionary symbol                */

#if (defined (SMT_TRACE))
    trace ("semaph_lookup: semaph=%s", semaph_name);
#endif
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (NULL);
      }

    dict_entry = sym_lookup_symbol (dict, get_semaph_name (semaph_name));
    if (dict_entry == NULL)
      {
         smt_errno = SMT_NOSUCHSEMAPH;
         return (NULL);
      }
    return (dict_entry-&gt; data);         /*  Return pointer to SEMAPH         */
}
</PRE>
<A NAME="semaph_destroy">&nbsp;</A>
<H3><A NAME="TOC100"><TT>semaph_destroy</TT></A></H3>
<PRE>
#include "smtlib.h"
int
semaph_destroy (
    SEMAPH *semaph                      /*  Semaph to destroy; null = all    */
)
</PRE>
<H4>Synopsis</H4>
<P>Destroys the semaphore. Returns 0 when completed. The semaph
   argument points to an semaph block, or is null. If null, all
   semaphores are destroyed. Returns 0 when completed normally,
   else returns -1 and sets smt_errno to one of these values:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT NOTREADY</B>
   <TD ALIGN="LEFT">smt_init() was not called, or failed </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("semaph_destroy: semaph=%s", semaph? semaph-&gt; name: "ALL");
#endif
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    if (semaph == NULL)                 /*  Destroy all semaphs if wanted    */
        while (semaphs.next != &amp;semaphs)
            <A href="smtdoc.htm#semaph_destroy">semaph destroy</A> (semaphs.next);
    else                                /*  Else destroy this semaph         */
      {
        /*  We have to be a little careful or sym_delete_symbol () will      */
        /*  try to release the symbol's data area; the data area points      */
        /*  to our node, which we want to release ourselves.                 */
        semaph-&gt; symbol-&gt; data = NULL;
        sym_delete_symbol (dict, semaph-&gt; symbol);

        /*  Now delete the semaph                                            */
        mem_strfree (&amp;semaph-&gt; name);   /*  First we take its name           */
        node_destroy (semaph);          /*  ... then we take its life        */
      }
    return (0);
}
</PRE>
<A NAME="semaph_wait">&nbsp;</A>
<H3><A NAME="TOC101"><TT>semaph_wait</TT></A></H3>
<PRE>
#include "smtlib.h"
int
semaph_wait (
    SEMAPH *semaph                      /*  Semaph to wait for               */
)
</PRE>
<H4>Synopsis</H4>
<P>When the semaphore value is &gt; 0, subtracts 1 from the
   semaphore value. If necessary, suspends the thread until this
   happens. Threads are re-started on a FIFO basis. Call as last
   statement in an action module. Returns 0 when completed
   normally, else returns -1 and sets smt_errno to one of these
   values: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT
   NOTREADY</B>  <TD ALIGN="LEFT">smt_init() was not called, or
   failed </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("semaph_wait");
#endif
    ASSERT (semaph);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    if (semaph-&gt; value &gt; 0)             /*  If semaphore is &gt; 0              */
        semaph-&gt; value--;               /*    then we can continue           */
    else
      {                                 /*  Else break on semaphore          */
        break_wanted = BREAK_WAIT_SEMAPH;
        break_semaph = semaph;
      }
    return (0);
}
</PRE>
<A NAME="semaph_signal">&nbsp;</A>
<H3><A NAME="TOC102"><TT>semaph_signal</TT></A></H3>
<PRE>
#include "smtlib.h"
int
semaph_signal (
    SEMAPH *semaph                      /*  Semaph to signal                 */
)
</PRE>
<H4>Synopsis</H4>
<P>Adds 1 to the semaphore value. Returns 0 when completed
   normally, else returns -1 and sets smt_errno to one of these
   values: <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>SMT
   NOTREADY</B>  <TD ALIGN="LEFT">smt_init() was not called, or
   failed </TABLE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("semaph_signal");
#endif
    ASSERT (semaph);
    if (!smt_alive)                     /*  If SMT API was not correctly     */
      {                                 /*    initialised, forget it         */
        smt_errno = SMT_NOTREADY;
        return (-1);
      }

    semaph-&gt; value++;                   /*  Bump semaphore value             */
    return (0);                         /*    initialised, forget it         */
}
</PRE>
<A NAME="lazy_creat">&nbsp;</A>
<H3><A NAME="TOC103"><TT>lazy_creat</TT></A></H3>
<PRE>
#include "smtlib.h"
int
lazy_creat (char *path, int mode)
</PRE>
<H4>Synopsis</H4>
<P>Calls the standard creat() function without blocking.
   (Actually, calls the open() function, but with the O_CREAT
   flag.) Returns a file handle when the call succeeds, else
   returns -1 and sets errno to the cause of the error. The file
   is always opened in binary mode, and you must process control
   characters yourself. We use open() so that we can force
   O_NONBLOCK. If the call would block, returns -1, sets errno to
   EAGAIN, and calls <A href="smtdoc.htm#recycle_module">recycle module</A>() to re-execute the
   current dialog module automatically. You can override this
   behavious by calling <A href="smtdoc.htm#recycle_module">recycle module</A> (FALSE) after the
   return. Sets the global variable "io_completed" to TRUE if the
   i/o access completed, with or without an error.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    int rc;

#if (defined (SMT_TRACE))
    trace ("lazy_create: path=%s", path);
#endif
    rc = open (path, O_CREAT | O_WRONLY | O_TRUNC | O_NONBLOCK | O_BINARY,
               mode);

    set_io_completed (rc);
    return (rc);
}
</PRE>
<A NAME="lazy_creat_text">&nbsp;</A>
<H3><A NAME="TOC104"><TT>lazy_creat_text</TT></A></H3>
<PRE>
#include "smtlib.h"
int
lazy_creat_text (char *path, int mode)
</PRE>
<H4>Synopsis</H4>
<P>Calls the standard creat() function without blocking.
   (Actually, calls the open() function, but with the O_CREAT
   flag.) Returns a file handle when the call succeeds, else
   returns -1 and sets errno to the cause of the error. The file
   is always opened in text mode. We use open() so that we can
   force O_NONBLOCK. If the call would block, returns -1, sets
   errno to EAGAIN, and calls <A href="smtdoc.htm#recycle_module">recycle module</A>() to re-execute
   the current dialog module automatically. You can override this
   behavious by calling <A href="smtdoc.htm#recycle_module">recycle module</A> (FALSE) after the
   return. Sets the global variable "io_completed" to TRUE if the
   i/o access completed, with or without an error.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    int rc;

#if (defined (SMT_TRACE))
    trace ("lazy_create_text: path=%s", path);
#endif
    rc = open (path, O_CREAT | O_WRONLY | O_TRUNC | O_NONBLOCK, mode);
    set_io_completed (rc);
    return (rc);
}
</PRE>
<A NAME="lazy_open">&nbsp;</A>
<H3><A NAME="TOC105"><TT>lazy_open</TT></A></H3>
<PRE>
#include "smtlib.h"
int
lazy_open (char *path, int flags)
</PRE>
<H4>Synopsis</H4>
<P>Calls the standard open() function without blocking. Returns a
   file handle when the call succeeds, else returns -1 and sets
   errno to the cause of the error. The file is always opened in
   binary mode, and you must process control characters yourself.
   If the call would block, returns -1, sets errno to EAGAIN, and
   calls <A href="smtdoc.htm#recycle_module">recycle module</A>() to re-execute the current dialog
   module automatically. You can override this behavious by
   calling <A href="smtdoc.htm#recycle_module">recycle module</A> (FALSE) after the return. Sets the
   global variable "io_completed" to TRUE if the i/o access
   completed, with or without an error.
<H4>Examples</H4>
<PRE>
    handle_input  = lazy_open (filename, O_RDONLY);
    handle_output = lazy_open (filename, O_WRONLY | O_CREAT | O_TRUNC);
    handle_append = lazy_open (filename, O_WRONLY | O_CREAT | O_APPEND);
    if (io_completed && handle &lt; 0)
        have error on file
</PRE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    int rc;

#if (defined (SMT_TRACE))
    trace ("lazy_open: path=%s", path);
#endif
    rc = open (path, flags | O_NONBLOCK | O_BINARY, S_IREAD | S_IWRITE);
    set_io_completed (rc);
    return (rc);
}
</PRE>
<A NAME="lazy_open_text">&nbsp;</A>
<H3><A NAME="TOC106"><TT>lazy_open_text</TT></A></H3>
<PRE>
#include "smtlib.h"
int
lazy_open_text (char *path, int flags)
</PRE>
<H4>Synopsis</H4>
<P>As <A href="smtdoc.htm#lazy_open">lazy open</A>(), but opens the file in text mode, on those
   platforms where this makes a difference.
<H4>Examples</H4>
<PRE>
    handle_input  = lazy_open (filename, O_RDONLY);
    handle_output = lazy_open (filename, O_WRONLY | O_CREAT | O_TRUNC);
    handle_append = lazy_open (filename, O_WRONLY | O_CREAT | O_APPEND);
    if (io_completed && handle &lt; 0)
        have error on file
</PRE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    int rc;

#if (defined (SMT_TRACE))
    trace ("lazy_open_text: path=%s", path);
#endif
    rc = open (path, flags | O_NONBLOCK, S_IREAD | S_IWRITE);
    set_io_completed (rc);
    return (rc);
}
</PRE>
<A NAME="lazy_read">&nbsp;</A>
<H3><A NAME="TOC107"><TT>lazy_read</TT></A></H3>
<PRE>
#include "smtlib.h"
int
lazy_read (int handle, char *buffer, size_t count)
</PRE>
<H4>Synopsis</H4>
<P>Calls the standard read() function without blocking. Returns
   the number of bytes read when the call succeeds, else returns -
   1 and sets errno to the cause of the error. If the call would
   block, returns -1, sets errno to EAGAIN, and calls
   <A href="smtdoc.htm#recycle_module">recycle module</A>() to re-execute the current dialog module
   automatically. You can override this behavious by calling
   <A href="smtdoc.htm#recycle_module">recycle module</A> (FALSE) after the return. Sets the global
   variable "io_completed" to TRUE if the i/o access completed,
   with or without an error.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    int rc;

#if (defined (SMT_TRACE))
    trace ("lazy_read: handle=%d bytes=%d", handle, count);
#endif
    rc = read (handle, buffer, count);
    set_io_completed (rc);
    return (rc);
}
</PRE>
<A NAME="lazy_write">&nbsp;</A>
<H3><A NAME="TOC108"><TT>lazy_write</TT></A></H3>
<PRE>
#include "smtlib.h"
int
lazy_write (int handle, char *buffer, size_t count)
</PRE>
<H4>Synopsis</H4>
<P>Calls the standard write() function without blocking. Returns
   the number of bytes written when the call succeeds, else
   returns -1 and sets errno to the cause of the error. If the
   call would block, returns -1, sets errno to EAGAIN, and calls
   <A href="smtdoc.htm#recycle_module">recycle module</A>() to re-execute the current dialog module
   automatically. You can override this behavious by calling
   <A href="smtdoc.htm#recycle_module">recycle module</A> (FALSE) after the return. Sets the global
   variable "io_completed" to TRUE if the i/o access completed,
   with or without an error.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    int rc;

#if (defined (SMT_TRACE))
    trace ("lazy_write: handle=%d bytes=%d", handle, count);
#endif
    rc = write (handle, buffer, count);
    set_io_completed (rc);
    return (rc);
}
</PRE>
<A NAME="lazy_close">&nbsp;</A>
<H3><A NAME="TOC109"><TT>lazy_close</TT></A></H3>
<PRE>
#include "smtlib.h"
int
lazy_close (int handle)
</PRE>
<H4>Synopsis</H4>
<P>Calls the standard close() function without blocking. Returns 0
   when the call succeeds, else returns -1 and sets errno to the
   cause of the error. If the call would block, returns -1, sets
   errno to EAGAIN, and calls <A href="smtdoc.htm#recycle_module">recycle module</A>() to re-execute
   the current dialog module automatically. You can override this
   behavious by calling <A href="smtdoc.htm#recycle_module">recycle module</A> (FALSE) after the
   return. Sets the global variable "io_completed" to TRUE if the
   i/o access completed, with or without an error.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    int rc;

#if (defined (SMT_TRACE))
    trace ("lazy_close: handle=%d", handle);
#endif
    rc = close (handle);
    set_io_completed (rc);
    return (rc);
}
</PRE>
<A NAME="senderr">&nbsp;</A>
<H3><A NAME="TOC110"><TT>senderr</TT></A></H3>
<PRE>
#include "smtlib.h"
int
senderr (const QID *to_queue)
</PRE>
<H4>Synopsis</H4>
<P>Sends an "ERROR" event to the specified queue, with the value
   of strerror (errno) as event body. Use this to reply after some
   i/o access failed. Return values are the same as for
   <A href="smtdoc.htm#event_send">event send</A>().
<H4>Examples</H4>
<PRE>
    senderr (&thread-&gt; event-&gt; sender);
</PRE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    char
        *message = strerror (errno);

#if (defined (SMT_TRACE))
    trace ("senderr: error=%s", message);
#endif
    return (<A href="smtdoc.htm#event_send">event send</A> (
        to_queue,                       /*  Send to specified queue          */
        NULL,                           /*  No queue for reply               */
        "ERROR",                        /*  Name of event to send            */
        (byte *) message,               /*  Event body to send               */
        strlen (message),               /*  Event body size                  */
        NULL, NULL, NULL,               /*  No response events               */
        0));                            /*  No timeout                       */
}
</PRE>
<A NAME="sendfmt">&nbsp;</A>
<H3><A NAME="TOC111"><TT>sendfmt</TT></A></H3>
<PRE>
#include "smtlib.h"
int
sendfmt (const QID *to_queue, char *name, char *format, ...)
</PRE>
<H4>Synopsis</H4>
<P>Sends a text message to the specified queue. The caller can
   specify a printf()-type format string and insertion values.
   Return values are the same as for <A href="smtdoc.htm#event_send">event send</A>().
<H4>Examples</H4>
<PRE>
    sendfmt (&console, "INFO", "Error accessing %s file", filename);
</PRE>
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    static char
        formatted [4096];               /*  Formatted string                 */
    va_list
        argptr;                         /*  Argument list pointer            */

#if (defined (SMT_TRACE))
    trace ("sendfmt: name=%s format=%s", name, format);
#endif

    va_start (argptr, format);          /*  Start variable args processing   */
#if (defined (DOES_SNPRINTF))
    vsnprintf (formatted, 4096, format, argptr);
#else
    vsprintf  (formatted, format, argptr);
#endif
    va_end (argptr);                    /*  End variable args processing     */

    return (<A href="smtdoc.htm#event_send">event send</A> (
        to_queue,                       /*  Send to specified queue          */
        NULL,                           /*  No queue for reply               */
        name,                           /*  Name of event to send            */
        (byte *) formatted,             /*  Event body to send               */
        strlen (formatted) + 1,         /*  Event body size, including null  */
        NULL, NULL, NULL,               /*  No response events               */
        0));                            /*  No timeout                       */
}
</PRE>
<A NAME="raise_exception">&nbsp;</A>
<H3><A NAME="TOC112"><TT>raise_exception</TT></A></H3>
<PRE>
#include "smtlib.h"
void
raise_exception (event_t event)
</PRE>
<H4>Synopsis</H4>
<P>Sets the exception_raised flag to TRUE and sets the exception
   event as specified. To raise an exception without setting the
   exception event, just do this: 'exception_raised = TRUE;'.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("raise_exception");
#endif
    _exception_raised    = TRUE;
    _the_exception_event = event;
}
</PRE>
<A NAME="recycle_module">&nbsp;</A>
<H3><A NAME="TOC113"><TT>recycle_module</TT></A></H3>
<PRE>
#include "smtlib.h"
void
recycle_module (Bool wanted)
</PRE>
<H4>Synopsis</H4>
<P>Tells the SMT kernel to repeat the current action module. This
   is a simple way to re-attempt an i/o that returned a 'EAGAIN'
   or 'EWOULDBLOCK' code. The lazy file access functions
   automatically call this function in case they failed. If you
   call this function with the wanted argument as FALSE, any
   previous recycle request is cancelled.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
#if (defined (SMT_TRACE))
    trace ("recycle_module");
#endif
    if (wanted)
        break_wanted = BREAK_RECYCLE;
    else
        break_wanted = BREAK_CONTINUE;
}
</PRE>
<A NAME="smt_set_step">&nbsp;</A>
<H3><A NAME="TOC114"><TT>smt_set_step</TT></A></H3>
<PRE>
#include "smtlib.h"
void
smt_set_step (const char *step)
</PRE>
<H4>Synopsis</H4>
<P>Sets the current module 'step'. Used to debug applications:
   suspect modules can set 'steps': the last of which is displayed
   when there is a SEGV crash. Must be called with a string
   (constant) value.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    cur_step = (char *) step;
}
</PRE>
<A NAME="smt_crash_report">&nbsp;</A>
<H3><A NAME="TOC115"><TT>smt_crash_report</TT></A></H3>
<PRE>
#include "smtlib.h"
char *
smt_crash_report (void)
</PRE>
<H4>Synopsis</H4>
<P>Returns a formatted string showing the current agent, state,
   module, step, event, and catch report, if any.
<H4>Source Code - (smtlib.c)</H4>
<PRE>
{
    static char
        report [512];

    sprintf (report, "Abort at %s:%s:%s (%s, %s)",
                      cur_agent, cur_module, cur_step,
                      cur_state, cur_event);
    return (report);
}
</PRE>
<H2><A NAME="TOC116">The Standard SMT Agents</A></H2>
<P>Filename: smtdefn.h
<BR>Package: Libero SMT 2.x
<BR>Written: 1996/05/27 iMatix SMT kernel team <A
   HREF=mailto:"smt@imatix.com">smt@imatix.com</A>
<BR>Revised: 1999/08/27
<BR>Copyright: Copyright (c) 1991-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Defines the standard agent prototypes and methods.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="smtdoc.htm#smtauth_init">smtauth init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smtecho_init">smtecho init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smthttp_init">smthttp init</A><BR>
   (char *rootdir, char *cgidir);
</LI>
<LI>int <A href="smtdoc.htm#smtlog_init">smtlog init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smtoper_init">smtoper init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smtslot_init">smtslot init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smtsock_init">smtsock init</A><BR>
   (void);
</LI>
<LI>void <A href="smtdoc.htm#smtsock_trace">smtsock trace</A><BR>
   (Bool trace);
</LI>
<LI>int <A href="smtdoc.htm#smttime_init">smttime init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smttran_init">smttran init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smtftpc_init">smtftpc init</A><BR>
   (char *root);
</LI>
<LI>int <A href="smtdoc.htm#smtftpd_init">smtftpd init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smtrdns_init">smtrdns init</A><BR>
   (void);
</LI>
<LI>int <A href="UNDEF">smtpipe init</A><BR>
   (char *pipefile);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>smtdefn.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SMT_ECHO</B>  </TT>
<TD ALIGN="LEFT">"smtecho" /* Name of TCP/IP echo agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_ECHO_PORT</B>  </TT>
<TD ALIGN="LEFT">"7" /* Port for echo agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_FTPC</B>  </TT>
<TD ALIGN="LEFT">"smtftpc" /* Name of FTP server control agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_FTPD</B>  </TT>
<TD ALIGN="LEFT">"smtftpd" /* Name of FTP server data agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_FTP_PORT</B>  </TT>
<TD ALIGN="LEFT">"21" /* Port for FTP agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_HTTP</B>  </TT>
<TD ALIGN="LEFT">"smthttp" /* Name of HTTP server agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_HTTP_PORT</B>  </TT>
<TD ALIGN="LEFT">"80" /* Port for HTTP agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_LOGGING</B>  </TT>
<TD ALIGN="LEFT">"smtlog" /* Name of logging agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_OPERATOR</B>  </TT>
<TD ALIGN="LEFT">"smtoper" /* Name of operator agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_RDNS</B>  </TT>
<TD ALIGN="LEFT">"smtrdns" /* Name of reverse dns agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SHTTP_PORT</B>  </TT>
<TD ALIGN="LEFT">"443" /* Port for SHTTP agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SLOT</B>  </TT>
<TD ALIGN="LEFT">"smtslot" /* Name of time slot agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SOCKET</B>  </TT>
<TD ALIGN="LEFT">"smtsock" /* Name of socket i/o agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_SSL</B>  </TT>
<TD ALIGN="LEFT">"smtssl" /* Name of SSL server agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_TIMER</B>  </TT>
<TD ALIGN="LEFT">"smttime" /* Name of timer agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_TRANSFER</B>  </TT>
<TD ALIGN="LEFT">"smttran" /* Name of transfer agent */
<TR><TD ALIGN="LEFT"><TT><B>_SMTDEFN_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="smtauth_init">&nbsp;</A>
<H3><A NAME="TOC117"><TT>smtauth_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smtauth_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT authorisation agent. Returns 0 if
   initialised okay, -1 if there was an error. Supports these
   public methods: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>OPEN</B>  <TD ALIGN="LEFT">Create a protected
   url symbol table. <TR><TD ALIGN="LEFT"><B>REOPEN</B>  <TD
   ALIGN="LEFT">Reload authorisation data <TR><TD
   ALIGN="LEFT"><B>CHECK URL</B>  <TD ALIGN="LEFT">Check if a url
   is protected. <TR><TD ALIGN="LEFT"><B>CHECK NAME</B>  <TD
   ALIGN="LEFT">Check user name and password for a url; returns
   user name. <TR><TD ALIGN="LEFT"><B>CLOSE</B>  <TD
   ALIGN="LEFT">Free symbol table and end thread. </TABLE> Sends
   errors to the SMTOPER agent.
<H4>Source Code - (smtauth.c)</H4>
<PRE>
{
    AGENT  *agent;                      /*  Handle for our agent             */
    THREAD *thread;                     /*  Handle to console thread         */
#   include "smtauth.i"                 /*  Include dialog interpreter       */

    /*                      Method name   Event value        Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",    shutdown_event,    SMT_PRIORITY_MAX);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "OPEN",        open_event,        0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "REOPEN",      reopen_event,      0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "CHECK_URL",   check_url_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "CHECK_NAME",  check_name_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "CLOSE",       close_event,       0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        console = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtecho_init">&nbsp;</A>
<H3><A NAME="TOC118"><TT>smtecho_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smtecho_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT echo agent. Returns 0 if initialised okay,
   -1 if there was an error. The echo agent handles the TCP ECHO
   protocol on port 7. It logs connections to the file
   smtecho.log. It sends errors to the SMTOPER agent. If you set
   the ip_portbase before calling this function, the echo port is
   shifted by that amount. A typical value for ip_portbase is
   5000: the echo agent will then handle connections on port 5007.
<H4>Source Code - (smtecho.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle to various threads        */
#   include "smtecho.i"                 /*  Include dialog interpreter       */

    /*                      Method name      Event value     Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",       shutdown_event, SMT_PRIORITY_MAX);

    /*  Reply events from socket agent                                       */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_INPUT_OK",  ok_event,       0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_OUTPUT_OK", ok_event,       0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READ_OK",   read_ok_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITE_OK",  write_ok_event, 0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_CLOSED",    closed_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_ERROR",     error_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_TIMEOUT",   error_event,    0);

    /*  Private methods used to pass initial thread events                   */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_MASTER",        master_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_CLIENT",        client_event,   0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        operq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that socket agent is running, else start it up                */
    <A href="smtdoc.htm#smtsock_init">smtsock init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_SOCKET, "")) != NULL)
        sockq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that logging agent is running, and create new thread          */
    <A href="smtdoc.htm#smtlog_init">smtlog init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (SMT_LOGGING, "")) != NULL)
        logq = thread-&gt; queue-&gt; qid;        /*  Get logging queue id         */
    else
        return (-1);

    /*  Create initial thread to manage master port                          */
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "")) != NULL)
      {
        SEND (&amp;thread-&gt; queue-&gt; qid, "_MASTER", "");
        ((TCB *) thread-&gt; tcb)-&gt; thread_type = master_event;
        ((TCB *) thread-&gt; tcb)-&gt; handle      = 0;
      }
    else
        return (-1);

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smthttp_init">&nbsp;</A>
<H3><A NAME="TOC119"><TT>smthttp_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int smthttp_init (char *p_rootdir,      /*  Document root directory          */
                  char *p_cgidir)       /*  CGI binary directory             */
</PRE>
<H4>Synopsis</H4>
<P>Initialises the HTTP agent. Returns 0 if initialised okay, -1
   if there was an error. The HTTP agent manages a HTTP service on
   port 80 (+ ip_portbase). Sends errors and information messages
   to the SMTOPER agent.
<H4>Source Code - (smthttp.c)</H4>
<PRE>
{
    AGENT  *agent;                      /*  Handle for our agent             */
    THREAD *thread;                     /*  Handle to various threads        */
#   include "smthttp.i"                 /*  Include dialog interpreter       */

    /*                      Method name      Event value     Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",       shutdown_event, SMT_PRIORITY_MAX);

    /*  Reply events from socket agent                                       */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_INPUT_OK",  ok_event,            0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_OUTPUT_OK", ok_event,            0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READ_OK",   ok_event,            0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITE_OK",  ok_event,            0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_CLOSED",    sock_closed_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_ERROR",     sock_error_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_TIMEOUT",   sock_timeout_event,  0);

    /*  Reply events from transfer agent                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_PUTF_OK",   finished_event,      0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_CLOSED",    sock_closed_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_ERROR",     sock_error_event,    0);

    /*  Registration events from WSX agents                                  */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_INSTALL",    wsx_install_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_CANCEL",     wsx_cancel_event,    0);

    /*  Reply events from WSX agents                                         */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_OK",         wsx_ok_event,        0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_MULTIPART",  wsx_multi_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_BIN",        wsx_binary_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_MBIN",       wsx_multibin_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_ERROR",      wsx_error_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_REDIRECT",   wsx_redirect_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_RESTART",    wsx_restart_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WSX_KILL",       wsx_kill_event,      0);

    /*  Reply events from timer agent                                        */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ALARM",     timer_event, SMT_PRIORITY_LOW);

    /*  Private methods used to pass initial thread events                   */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_MASTER",        master_event,        0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_CLIENT",        client_event,        0);

    /*  Private methods used between threads                                 */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_CANCEL",        cancel_event,        0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_RESTART",       restart_event,       0);

    /*  Reply events from SSL agents                                         */
    declare_ssl_accepted     (new_ssl_client_event, 0);
    declare_ssl_read_ok      (ok_event,             0);
    declare_ssl_open_ok      (ssl_open_event,       0);
    declare_ssl_error        (ssl_error_event,      0);
    declare_ssl_write_ok     (ok_event,             0);
    declare_ssl_put_slice_ok (finished_event,       0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        operq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that socket i/o agent is running, else start it up            */
    <A href="smtdoc.htm#smtsock_init">smtsock init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_SOCKET, "")) != NULL)
        sockq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Check whether SSL agent is running                                   */
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> ("SMTSSL", "main")) != NULL)
      {
        sslq = thread-&gt; queue-&gt; qid;
        server_secure = TRUE;
      }
    else
        server_secure = FALSE;

    /*  Ensure that timer agent is running, else start it up                 */
    <A href="smtdoc.htm#smttime_init">smttime init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TIMER, "")) != NULL)
        timeq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that transfer agent is running, else start it up              */
    <A href="smtdoc.htm#smttran_init">smttran init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TRANSFER, "")) != NULL)
        tranq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Create initial thread to manage master port                          */
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "main")) != NULL)
      {
        SEND (&amp;thread-&gt; queue-&gt; qid, "_MASTER", "");
        ((TCB *) thread-&gt; tcb)-&gt; thread_type = master_event;
        ((TCB *) thread-&gt; tcb)-&gt; handle      = 0;
      }
    else
        return (-1);

    this_agent = agent;                 /*  Handle to ourselves              */

    /*  Use standard port number.  Caller can set ip_portbase if wanted      */
    /*  to place the port into a specific area.                              */
    master_port = SMT_HTTP_PORT;

    http_init ();                       /*  Initialise HTTP library          */

    /*  Get root and cgi directories passed to smthttp.c                     */
    rootdir = p_rootdir;
    cgidir  = p_cgidir;

    /*  Get local host addresses table, which may be NULL                    */
    hostaddrs = get_hostaddrs ();

    /*  These strings are allocated if not null - initialise now             */
    request_log = NULL;
    header_log  = NULL;

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtftpc_init">&nbsp;</A>
<H3><A NAME="TOC120"><TT>smtftpc_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smtftpc_init (char *p_rootdir)          /*  Server root directory            */
</PRE>
<H4>Synopsis</H4>
<P>Initialises the FTP control agent. Returns 0 if initialised
   okay, -1 if there was an error.
<H4>Source Code - (smtftpc.c)</H4>
<PRE>
{
    AGENT  *agent;                      /*  Handle for our agent             */
    THREAD *thread;                     /*  Handle to various threads        */

#   include "smtftpc.i"                 /*  Include dialog interpreter       */

    /*                      Method name      Event value     Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",       shutdown_event,
                                             SMT_PRIORITY_MAX);

    /*  Restart can come from control panel and HTTP agent                   */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "RESTART",        restart_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "RELOAD",         reload_event,    0);

    /*  Reply events from socket agent                                       */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_INPUT_OK",  input_ok_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_OUTPUT_OK", ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READ_OK",   ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITE_OK",  ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_CLOSED",    sock_closed_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_ERROR",     sock_error_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_TIMEOUT",   sock_timeout_event, 0);

    /*  Reply events from timer agent                                        */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ALARM",     timeout_event,
                                             SMT_PRIORITY_LOW);
    /*  Reply events from FTP data agent                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_CONNECTED", connected_event,
                                             SMT_PRIORITY_LOW);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_ERROR",     error_event,
                                             SMT_PRIORITY_LOW);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_END",       end_event,
                                             SMT_PRIORITY_HIGH);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_PASS_OK",   ok_event,
                                             SMT_PRIORITY_LOW);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_ABORTED",   aborted_event,
                                             SMT_PRIORITY_HIGH);

    /*  Private methods used to pass initial thread events                   */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_MASTER",        master_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_CLIENT",        client_event,    0);

    /*  Private methods used between threads                                 */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_CANCEL",        cancel_event,    0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        operq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that socket i/o agent is running, else start it up            */
    <A href="smtdoc.htm#smtsock_init">smtsock init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_SOCKET, "")) != NULL)
        sockq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that timer agent is running, else start it up                 */
    <A href="smtdoc.htm#smttime_init">smttime init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TIMER, "")) != NULL)
        timeq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that FTP data agent is running, else start it up              */
    <A href="smtdoc.htm#smtftpd_init">smtftpd init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_FTPD, "")) != NULL)
        dataq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Create initial thread to manage master port                          */
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "main")) != NULL)
      {
        SEND (&amp;thread-&gt; queue-&gt; qid, "_MASTER", "");
        ((TCB *) thread-&gt; tcb)-&gt; thread_type = master_event;
        ((TCB *) thread-&gt; tcb)-&gt; handle      = 0;
      }
    else
        return (-1);

    this_agent = agent;                 /*  Handle to ourselves              */

    ftp_initialise ();

    /*  Get root directory                                                   */
    rootdir = mem_strdup (p_rootdir);

    /*  Get local host addresses table, which may be NULL                    */
    hostaddrs = get_hostaddrs ();

    /*  Signal to caller that we initialised okay                            */
    return (0);
}
</PRE>
<A NAME="smtftpd_init">&nbsp;</A>
<H3><A NAME="TOC121"><TT>smtftpd_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int smtftpd_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the FTP data agent. Returns 0 if initialised okay,
   -1 if there was an error.
<H4>Source Code - (smtftpd.c)</H4>
<PRE>
{
    AGENT
        *agent;                         /*  Handle for our agent             */
    THREAD
        *thread;                        /*  Handle to various threads        */
#   include "smtftpd.i"                 /*  Include dialog interpreter       */

    /*                      Method name      Event value     Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN", shutdown_event, SMT_PRIORITY_MAX);

    /*  Reply events from socket agent                                       */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_INPUT_OK",    ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_OUTPUT_OK",   ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READ_OK",     ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITE_OK",    ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_CLOSED",      sock_closed_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_ERROR",       sock_error_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_TIMEOUT",     sock_timeout_event, 0);

    /*  Reply events from transfer agent                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_PUTF_OK",     finished_event,
                                               SMT_PRIORITY_HIGH);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_GETF_OK",     finished_event,
                                               SMT_PRIORITY_HIGH);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_CLOSED",      sock_closed_event,
                                               SMT_PRIORITY_HIGH);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_ERROR",       sock_error_event,
                                               SMT_PRIORITY_HIGH);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_PASSIVE",     passive_event,
                                               SMT_PRIORITY_LOW);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_PUT_FILE",    put_file_event,
                                               SMT_PRIORITY_NORMAL);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_GET_FILE",    get_file_event,
                                               SMT_PRIORITY_NORMAL);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_APPEND_FILE", append_file_event,
                                               SMT_PRIORITY_NORMAL);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_ABORT",       abort_event,
                                               SMT_PRIORITY_HIGH);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FTPD_CLOSECTRL",   close_control_event,
                                               SMT_PRIORITY_HIGH);

    /*  Private method used to pass initial thread events                    */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_MASTER",          master_event, 0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        operq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that socket i/o agent is running, else start it up            */
    <A href="smtdoc.htm#smtsock_init">smtsock init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_SOCKET, "")) != NULL)
        sockq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that timer agent is running, else start it up                 */
    <A href="smtdoc.htm#smttime_init">smttime init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TIMER, "")) != NULL)
        timeq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that transfer agent is running, else start it up              */
    <A href="smtdoc.htm#smttran_init">smttran init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TRANSFER, "")) != NULL)
        tranq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Create initial thread to manage master port                          */
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "")) != NULL)
      {
        SEND (&amp;thread-&gt; queue-&gt; qid, "_MASTER", "");
        ((TCB *) thread-&gt; tcb)-&gt; thread_type = master_event;
      }
    else
        return (-1);

    pasv_port = sym_create_table ();

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtrdns_init">&nbsp;</A>
<H3><A NAME="TOC122"><TT>smtrdns_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int smtrdns_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the reverse DNS agent. Returns 0 if initialised
   okay, -1 if there was an error.
<H4>Source Code - (smtrdns.c)</H4>
<PRE>
{
    AGENT  *agent;                      /*  Handle for our agent             */
    THREAD *thread;                     /*  Handle to various threads        */

#   include "smtrdns.i"                 /*  Include dialog interpreter       */

    /*                      Method name      Event value     Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",       shutdown_event,
                                             SMT_PRIORITY_MAX);
    /*  Reply events from socket agent                                       */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_INPUT_OK",  input_ok_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_OUTPUT_OK", ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READ_OK",   ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITE_OK",  ok_event,           0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_CLOSED",    sock_closed_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_ERROR",     sock_error_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_TIMEOUT",   sock_timeout_event, 0);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "GET_HOST_NAME",  get_host_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "GET_HOST_IP",    get_ip_event,       0);

    /*  Reply events from timer agent                                        */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ALARM",     timer_event, SMT_PRIORITY_LOW);

    /*  Private methods used to pass initial thread events                   */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_MASTER",        master_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_CLIENT",        client_event,    0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        operq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that socket i/o agent is running, else start it up            */
    <A href="smtdoc.htm#smtsock_init">smtsock init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_SOCKET, "")) != NULL)
        sockq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that timer agent is running, else start it up                 */
    <A href="smtdoc.htm#smttime_init">smttime init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TIMER, "")) != NULL)
        timeq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Create initial thread to manage master port                          */
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "")) != NULL)
      {
        SEND (&amp;thread-&gt; queue-&gt; qid, "_MASTER", "");
        ((TCB *) thread-&gt; tcb)-&gt; thread_type = master_event;
      }
    else
        return (-1);

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtlog_init">&nbsp;</A>
<H3><A NAME="TOC123"><TT>smtlog_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smtlog_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT logging agent. Returns 0 if initialised
   okay, -1 if there was an error. The logging agent writes data
   to log files. Create an unnamed thread for each log file you
   want to manage, then send events to that thread. Supports these
   public methods: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>CYCLE</B>  <TD ALIGN="LEFT">Cycle log file if
   it already exists. <TR><TD ALIGN="LEFT"><B>OPEN</B>  <TD
   ALIGN="LEFT">Start a new logfile as specified by event body.
   <TR><TD ALIGN="LEFT"><B>APPEND</B>  <TD ALIGN="LEFT">Append to
   an existing logfile as specified by event body. <TR><TD
   ALIGN="LEFT"><B>PUT</B>  <TD ALIGN="LEFT">Write line to logile,
   prefixed by date and time. <TR><TD ALIGN="LEFT"><B>PLAIN</B>
   <TD ALIGN="LEFT">Use plain logfile output (no timestamp).
   <TR><TD ALIGN="LEFT"><B>STAMP</B>  <TD ALIGN="LEFT">Put
   timestamp at start of each logged line. <TR><TD
   ALIGN="LEFT"><B>CLOSE</B>  <TD ALIGN="LEFT">Close logfile and
   destroy thread. </TABLE> Sends errors to the SMTOPER agent;
   does not send reply events.
<H4>Source Code - (smtlog.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle to console thread         */
#   include "smtlog.i"                  /*  Include dialog interpreter       */

    /*                      Method name   Event value     Priority           */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",    shutdown_event, SMT_PRIORITY_MAX);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "CYCLE",       cycle_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "OPEN",        open_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "APPEND",      append_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "PUT",         put_event,      0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "PLAIN",       plain_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "STAMP",       stamp_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "CLOSE",       close_event,    0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        console = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtoper_init">&nbsp;</A>
<H3><A NAME="TOC124"><TT>smtoper_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smtoper_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT operator agent. Returns 0 if initialised
   okay, -1 if there was an error. The operator agent writes
   messages to the standard error device. More sophisticated
   implementations could send messages to consoles. Creates one
   unnamed thread automatically. Supports these public methods:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>ERROR</B>  <TD
   ALIGN="LEFT">Handle event as a serious error message. <TR><TD
   ALIGN="LEFT"><B>WARNING</B>  <TD ALIGN="LEFT">Handle event as a
   warning message. <TR><TD ALIGN="LEFT"><B>INFO</B>  <TD
   ALIGN="LEFT">Handle event as an information message. <TR><TD
   ALIGN="LEFT"><B>SET LOG</B>  <TD ALIGN="LEFT">Send all output
   to specified thread. <TR><TD ALIGN="LEFT"><B>DISABLE</B>  <TD
   ALIGN="LEFT">Console ignores all messages. <TR><TD
   ALIGN="LEFT"><B>ENABLE</B>  <TD ALIGN="LEFT">Console handles
   messages (default). </TABLE> Does not send reply events.
<H4>Source Code - (smtoper.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle for initial thread        */

#   include "smtoper.i"                 /*  Include dialog interpreter       */

    /*  We give this agent a high priority, so that we get to see messages   */
    /*  and errors as soon as possible.                                      */
    agent-&gt; priority = SMT_PRIORITY_HIGH;

    /*                      Method name     Event value      Priority        */
    /*  Shutdown event comes from Kernel, normal priority so we can show     */
    /*  incoming messages before we shut down.                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",      shutdown_event,  0);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SET_LOG",       log_event,       0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "ERROR",         error_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WARNING",       warning_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "INFO",          info_event,      0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "DISABLE",       disable_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "ENABLE",        enable_event,    0);

    /*  Create initial, unnamed thread                                       */
    thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "");
    <A href="smtdoc.htm#smt_set_console">smt set console</A> (&amp;thread-&gt; queue-&gt; qid);

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtslot_init">&nbsp;</A>
<H3><A NAME="TOC125"><TT>smtslot_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smtslot_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT time slot agent. Returns 0 if initialised
   okay, -1 if there was an error. The time slot agent manages
   time slots. You create a named thread, then send SPECIFY events
   to define the various time slots for your application. Then you
   send an ON or OFF event to initialise the timer. The time slot
   agent then sends SWITCH_ON and SWITCH_OFF events as required. A
   slot specification is a string, in the format: "name value
   ...". The name field is a day name ("mon"-"sun"), a date in MD
   order ("12/31") or a date in YMD order ("95/12/31"). The value
   is a list of times in 24 hour HH:MM[-HH:MM] format ("7:30-12:30
   13:30-17:30 17:35"). A value "off" clears all time slots for
   that day. The time slot accuracy is SLOT_TICK csecs. Any day
   that does not have specified values is switched 'off'. Supports
   these public methods: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>SPECIFY</B>  <TD ALIGN="LEFT">Define a time
   slot specification. <TR><TD ALIGN="LEFT"><B>RESET</B>  <TD
   ALIGN="LEFT">Reset all time slots. <TR><TD
   ALIGN="LEFT"><B>ON</B>  <TD ALIGN="LEFT">Initialise timer -
   application is switched on. <TR><TD ALIGN="LEFT"><B>OFF</B>
   <TD ALIGN="LEFT">Initialise timer - application is switched
   off. <TR><TD ALIGN="LEFT"><B>FINISH</B>  <TD ALIGN="LEFT">End
   time slot thread. </TABLE> Sends errors to the SMTOPER agent;
   see doc for reply events.
<H4>Source Code - (smtslot.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle to console thread         */
#   include "smtslot.i"                 /*  Include dialog interpreter       */

    /*                      Method name   Event value      Priority          */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",    shutdown_event,  SMT_PRIORITY_MAX);

    /*  Alarm event sent by timer to this agent                              */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ALARM",  tick_event,      0);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SPECIFY",     specify_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "RESET",       reset_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "ON",          on_event,        0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "OFF",         off_event,       0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FINISH",      finish_event,    0);

    /*  Ensure that timer agent is running, else start it up                 */
    <A href="smtdoc.htm#smttime_init">smttime init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TIMER, "")) != NULL)
        timeq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtsock_init">&nbsp;</A>
<H3><A NAME="TOC126"><TT>smtsock_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smtsock_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT socket agent. Returns 0 if initialised
   okay, -1 if there was an error. The socket agent manages all
   sockets (TCP and UPD) used by an SMT application. Creates an
   unnamed thread automatically: send events to that thread.
   Initialises the sflsock socket interface automatically.
   Supports these public methods: <TABLE BORDER NOWRAP> <TR><TD
   ALIGN="LEFT"><B>READ</B>  <TD ALIGN="LEFT">Read a specified
   amount of input data (use SMT_SOCK_READ). <TR><TD
   ALIGN="LEFT"><B>WRITE</B>  <TD ALIGN="LEFT">Write a specified
   amount of output data (use SMT_SOCK_WRITE). <TR><TD
   ALIGN="LEFT"><B>READR</B>  <TD ALIGN="LEFT">Read input data,
   repeatedly (use SMT_SOCK_READ). <TR><TD
   ALIGN="LEFT"><B>READH</B>  <TD ALIGN="LEFT">As for READ, but
   for blocks &gt; 64k (use SMT_SOCK_READH). <TR><TD
   ALIGN="LEFT"><B>WRITEH</B>  <TD ALIGN="LEFT">As for WRITE, but
   for blocks &gt; 64k (use SMT_SOCK_WRITEH). <TR><TD
   ALIGN="LEFT"><B>READRH</B>  <TD ALIGN="LEFT">As for READR, but
   for blocks &gt; 64k (use SMT_SOCK_READH). <TR><TD
   ALIGN="LEFT"><B>INPUT</B>  <TD ALIGN="LEFT">Wait for any input
   ready on socket (use SMT_SOCK_INPUT). <TR><TD
   ALIGN="LEFT"><B>INPUTR</B>  <TD ALIGN="LEFT">Wait for any
   input, repeatedly (use SMT_SOCK_INPUT). <TR><TD
   ALIGN="LEFT"><B>OUTPUT</B>  <TD ALIGN="LEFT">Wait for any
   output ready on socket (use SMT_SOCK_OUTPUT). <TR><TD
   ALIGN="LEFT"><B>CONNECT</B>  <TD ALIGN="LEFT">Make socket
   connection to host &amp; port (use SMT_SOCK_CONNECT). <TR><TD
   ALIGN="LEFT"><B>FLUSH</B>  <TD ALIGN="LEFT">Delete all requests
   for specified socket (use SMT_SOCK_FLUSH). </TABLE> Sends
   errors to the SMTOPER agent; see doc for reply events.
<H4>Source Code - (smtsock.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle to console thread         */
#   include "smtsock.i"                 /*  Include dialog interpreter       */

    /*  We give this agent a low priority, so that it will only run after    */
    /*  all other threads.  This is important, since it blocks on select().  */
    agent-&gt; priority = SMT_PRIORITY_LOW;

    /*                      Method name     Event value      Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",      shutdown_event,  SMT_PRIORITY_MAX);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "READ",          read_event,      0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "READR",         readr_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "READH",         readh_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "READRH",        readrh_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WRITE",         write_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WRITEH",        writeh_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "INPUT",         input_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "INPUTR",        inputr_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "OUTPUT",        output_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "CONNECT",       connect_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FLUSH",         flush_event,     0);

    /*  Private method used to cycle on select() call                        */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_TIMEOUT",      timeout_event,   0);

    /*  Ensure that operator console is running, else start it up            */
    if (<A href="smtdoc.htm#agent_lookup">agent lookup</A> (SMT_OPERATOR) == NULL)
        <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        operq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Initialise the socket interface and register sock_term()             */
    if (sock_init () == 0)
        <A href="smtdoc.htm#smt_atexit">smt atexit</A> ((function) sock_term);
    else
      {
        <A href="smtdoc.htm#sendfmt">sendfmt</A> (&amp;operq, "ERROR",
                 "smtsock: could not initialise socket interface");
        <A href="smtdoc.htm#sendfmt">sendfmt</A> (&amp;operq, "ERROR",
                 "smtsock: %s", connect_errlist [connect_error ()]);
        return (-1);
      }

    ip_nonblock = TRUE;                  /*  Want nonblocking sockets        */

    /*  Create initial, unnamed thread                                       */
    <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "");

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtsock_trace">&nbsp;</A>
<H3><A NAME="TOC127"><TT>smtsock_trace</TT></A></H3>
<PRE>
#include "smtdefn.h"
void smtsock_trace (Bool trace_value)
</PRE>
<H4>Synopsis</H4>
<P>Enables/disables socket tracing: to enable, call with TRUE as
   argument; to disable call with FALSE as argument. Socket trace
   data is sent to the console.
<H4>Source Code - (smtsock.c)</H4>
<PRE>
{
    trace_flag = trace_value;
}
</PRE>
<A NAME="smttime_init">&nbsp;</A>
<H3><A NAME="TOC128"><TT>smttime_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smttime_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT timer agent. Returns 0 if initialised okay,
   -1 if there was an error. The timer agent provides timing
   events after a certain delay, at a specific time, or at a
   specific frequency. When you initialise the timer agent it
   creates an unnamed thread automatically. Send events to this
   thread. The timer accuracy is 1/100th of a second, depending on
   the system capacity and speed. Supports these public methods:
   <TABLE BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>ALARM</B>  <TD
   ALIGN="LEFT">Send an alarm after some delay (use
   SMT_TIME_ALARM). <TR><TD ALIGN="LEFT"><B>WAKEUP</B>  <TD
   ALIGN="LEFT">Send an alarm at some time (use SMT_TIME_ALARM).
   <TR><TD ALIGN="LEFT"><B>CLOCK</B>  <TD ALIGN="LEFT">Send an
   alarm at some frequency (use SMT_TIME_CLOCK). <TR><TD
   ALIGN="LEFT"><B>FLUSH</B>  <TD ALIGN="LEFT">Cancel all timing
   events for a client thread. </TABLE> Sends errors to the
   SMTOPER agent; see doc for reply events.
<H4>Source Code - (smttime.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
#   include "smttime.i"                 /*  Include dialog interpreter       */

    /*                      Method name      Event value     Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",       shutdown_event, SMT_PRIORITY_MAX);

    /*  Timer event sent by kernel to the timer agent (this program)         */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIMER",          timer_event,    0);

    /*  Private event, used to loop if no system timers are available        */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_TIMER",         timer_event,    SMT_PRIORITY_LOW);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "ALARM",          alarm_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "WAKEUP",         wakeup_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "CLOCK",          clock_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "FLUSH",          flush_event,    0);

    /*  Create initial, unnamed thread                                       */
    <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "");

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smttran_init">&nbsp;</A>
<H3><A NAME="TOC129"><TT>smttran_init</TT></A></H3>
<PRE>
#include "smtdefn.h"
int
smttran_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT transfer agent. Returns 0 if initialised
   okay, -1 if there was an error. The transfer agent reads and
   writes blocks of data, or complete files, through an open
   TCP/IP socket. A block of data is sent/received as a two-byte
   length header followed by the data block. Creates an unnamed
   thread automatically. Supports these public methods: <TABLE
   BORDER NOWRAP> <TR><TD ALIGN="LEFT"><B>PUT BLOCK</B>  <TD
   ALIGN="LEFT">Write a length-specified block to a socket (&lt;
   64k) <TR><TD ALIGN="LEFT"><B>GET BLOCK</B>  <TD
   ALIGN="LEFT">Read a length-specified block from a socket (&lt;
   64k) <TR><TD ALIGN="LEFT"><B>PUT HUGE</B>  <TD
   ALIGN="LEFT">Write a length-specified block to a socket (&lt;
   2Gb) <TR><TD ALIGN="LEFT"><B>GET HUGE</B>  <TD
   ALIGN="LEFT">Read a length-specified block from a socket (&lt;
   2Gb) <TR><TD ALIGN="LEFT"><B>PUT FILE</B>  <TD
   ALIGN="LEFT">Write part or all of a file to a socket <TR><TD
   ALIGN="LEFT"><B>GET FILE</B>  <TD ALIGN="LEFT">Read part or all
   of a file from a socket <TR><TD ALIGN="LEFT"><B>PIPE CREATE</B>
   <TD ALIGN="LEFT">Create new transfer pipe <TR><TD
   ALIGN="LEFT"><B>CLEAR PIPES</B>  <TD ALIGN="LEFT">Destroy all
   transfer pipes <TR><TD ALIGN="LEFT"><B>COMMIT</B>  <TD
   ALIGN="LEFT">Wait until all transfer requests are finished
   </TABLE> Sends errors to the SMTOPER agent; see the doc for
   reply events.
<H4>Source Code - (smttran.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle to various threads        */
#   include "smttran.i"                 /*  Include dialog interpreter       */

    /*                      Method name      Event value      Priority        */
    /*  Shutdown event comes from Kernel                                      */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",       shutdown_event,  SMT_PRIORITY_MAX);

    /*  Reply events from socket agent                                       */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_INPUT_OK",  ok_event,          0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_OUTPUT_OK", ok_event,          0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READ_OK",   read_ok_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITE_OK",  write_ok_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READH_OK",  readh_ok_event,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITEH_OK", writeh_ok_event,   0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_CLOSED",    sock_closed_event, 0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_ERROR",     sock_error_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_TIMEOUT",   sock_error_event,  0);

    /*  Reply events from timer agent                                        */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ALARM",     alarm_event,       0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ERROR",     error_event,       0);

    /*  Public methods supported by this agent                               */
    declare_put_block    (put_block_event,    0);
    declare_get_block    (get_block_event,    0);
    declare_put_huge     (put_huge_event,     0);
    declare_get_huge     (get_huge_event,     0);
    declare_put_file     (put_file_event,     0);
    declare_get_file     (get_file_event,     0);
    declare_pipe_create  (pipe_create_event,  0);
    declare_clear_pipes  (clear_pipes_event,  0);
    declare_tran_commit  (commit_event,       SMT_PRIORITY_MIN);

    /*  Private methods used to pass initial thread events                   */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_MASTER",       master_event,       0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "_PIPE_MANAGER", pipe_manager_event, 0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        operq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that socket agent is running, else start it up                */
    <A href="smtdoc.htm#smtsock_init">smtsock init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_SOCKET, "")) != NULL)
        sockq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that timer agent is running, else start it up                 */
    <A href="smtdoc.htm#smttime_init">smttime init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TIMER, "")) != NULL)
        timeq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Create initial thread to manage master thread                        */
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "")) != NULL)
      {
        SEND (&amp;thread-&gt; queue-&gt; qid, "_MASTER", "");
        ((TCB *) thread-&gt; tcb)-&gt; thread_type = master_event;
        ((TCB *) thread-&gt; tcb)-&gt; filename    = NULL;
      }
    else
        return (-1);

    /*  Create initial thread to manage pipes                                */
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "__pipe_manager")) != NULL)
      {
        SEND (&amp;thread-&gt; queue-&gt; qid, "_PIPE_MANAGER", "");
        ((TCB *) thread-&gt; tcb)-&gt; thread_type = pipe_manager_event;
        ((TCB *) thread-&gt; tcb)-&gt; filename    = NULL;
      }
    else
        return (-1);

    /*  Clear &amp; prepare request queue                                        */
    node_reset (&amp;requests);

    /*  Create pipe lookup table                                             */
    pipes = sym_create_table ();

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<H2><A NAME="TOC130">The Network Delay Simulator</A></H2>
<P>Filename: smtsimu.h
<BR>Package: Libero SMT 2.x
<BR>Written: 1996/11/28 iMatix SMT kernel team <A
   HREF=mailto:"smt@imatix.com">smt@imatix.com</A>
<BR>Revised: 1997/12/15
<BR>Copyright: Copyright (c) 1991-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Redefines socket functions to pass via smtsimu. Include
   smtsimu.h after smtlib.h when you want to simulate network
   delays. You do not need to change your program in any other
   way.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="smtdoc.htm#smtsimu_init">smtsimu init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smtsimu_smtsock_init">smtsimu smtsock init</A><BR>
   (void);
</LI>
<LI>void <A href="smtdoc.htm#smtsimu_smtsock_trace">smtsimu smtsock trace</A><BR>
   (Bool trace_value);
</LI>
<LI>int <A href="smtdoc.htm#smtsimu_sock_init">smtsimu sock init</A><BR>
   (void);
</LI>
<LI>int <A href="smtdoc.htm#smtsimu_write_UDP">smtsimu write UDP</A><BR>
   (SOCKET handle, void *buffer, size_t length, struct sockaddr_in
   *sin);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>smtsimu.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>_SMTSIMU_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
<TR><TD ALIGN="LEFT"><TT><B>smtsock_init</B>  </TT>
<TD ALIGN="LEFT">smtsimu_smtsock_init
<TR><TD ALIGN="LEFT"><TT><B>smtsock_trace</B>  </TT>
<TD ALIGN="LEFT">smtsimu_smtsock_trace
<TR><TD ALIGN="LEFT"><TT><B>sock_init</B>  </TT>
<TD ALIGN="LEFT">smtsimu_sock_init
<TR><TD ALIGN="LEFT"><TT><B>write_UDP</B>  </TT>
<TD ALIGN="LEFT">smtsimu_write_UDP
</TABLE>
<A NAME="smtsimu_init">&nbsp;</A>
<H3><A NAME="TOC131"><TT>smtsimu_init</TT></A></H3>
<PRE>
#include "smtsimu.h"
int
smtsimu_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT network delay simulation agent. Returns 0
   if okay, -1 if there was an error. You do not need to call this
   function explicitly. To use SMTSIMU, include "smtsimu.h" in
   your program after "smtlib.h". This redefines the standard
   socket functions to go through SMTSIMU. Sends all errors to the
   SMTOPER agent.
<H4>Source Code - (smtsimu.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle to console thread         */
#   include "smtsimu.i"                 /*  Include dialog interpreter       */

    /*                      Method name     Event value      Priority        */
    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN",      shutdown_event,  SMT_PRIORITY_MAX);

    /*  Public methods supported by this agent                               */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ALARM",    alarm_event,     0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TIME_ERROR",    error_event,     0);

    /*  Ensure that operator console is running, else start it up            */
    <A href="smtdoc.htm#smtoper_init">smtoper init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_OPERATOR, "")) != NULL)
        operq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that timer agent is running, else start it up               */
    <A href="smtdoc.htm#smttime_init">smttime init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TIMER, "")) != NULL)
        timeq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Create initial thread                                                */
    if ((thread = <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "")) != NULL)
        simuq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Initialise static variables */
    last_id = 0;

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}
</PRE>
<A NAME="smtsimu_sock_init">&nbsp;</A>
<H3><A NAME="TOC132"><TT>smtsimu_sock_init</TT></A></H3>
<PRE>
#include "smtsimu.h"
int
smtsimu_sock_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Replaces the normal sock_init() function call. Initialises the
   socket interface as usual, and then initialises the network
   delay simulation agent. Returns SOCKET_ERROR if there was an
   error, else returns 0.
<H4>Source Code - (smtsimu.c)</H4>
<PRE>
{
    /*  Really start sockets                                                 */
    if (sock_init ())
        return ((int) SOCKET_ERROR);

    /*  Now initialise the SMTSIMU agent, and return 0 or SOCKET_ERROR       */
    if (<A href="smtdoc.htm#smtsimu_init">smtsimu init</A> ())
        return ((int) SOCKET_ERROR);
    else
        return (0);
}
</PRE>
<A NAME="smtsimu_smtsock_init">&nbsp;</A>
<H3><A NAME="TOC133"><TT>smtsimu_smtsock_init</TT></A></H3>
<PRE>
#include "smtsimu.h"
int
smtsimu_smtsock_init (void)
</PRE>
<H4>Synopsis</H4>
<P>Replaces the normal <A href="smtdoc.htm#smtsock_init">smtsock init</A>() function call. Calls the
   SMTSOCK agent to initialise, as usual, then initialises the
   network delay simulation agent. Returns -1 if there was an
   error, else 0.
<H4>Source Code - (smtsimu.c)</H4>
<PRE>
{
    /*  Initialise SMTSOCK agent                                             */
    if (<A href="smtdoc.htm#smtsock_init">smtsock init</A> ())
        return (-1);

    /*  Now initialise the SMTSIMU agent                                     */
    return (<A href="smtdoc.htm#smtsimu_init">smtsimu init</A> ());
}
</PRE>
<A NAME="smtsimu_smtsock_trace">&nbsp;</A>
<H3><A NAME="TOC134"><TT>smtsimu_smtsock_trace</TT></A></H3>
<PRE>
#include "smtsimu.h"
void
smtsimu_smtsock_trace (Bool trace_value)
</PRE>
<H4>Synopsis</H4>
<P>Replaces the normal <A href="smtdoc.htm#smtsock_trace">smtsock trace</A>() function call. Calls
   the SMTSOCK agent to enable/disable tracing, then uses the same
   trace flag for the delay simulation. Tracing is sent to the
   operator console.
<H4>Source Code - (smtsimu.c)</H4>
<PRE>
{
    trace_flag = trace_value;
    <A href="smtdoc.htm#smtsock_trace">smtsock trace</A> (trace_value);
}
</PRE>
<A NAME="smtsimu_write_UDP">&nbsp;</A>
<H3><A NAME="TOC135"><TT>smtsimu_write_UDP</TT></A></H3>
<PRE>
#include "smtsimu.h"
int
smtsimu_write_UDP (
    sock_t handle,                      /*  Socket handle                    */
    void  *buffer,                      /*  Buffer containing data           */
    size_t length,                      /*  Amount of data to write          */
    struct sockaddr_in *sin             /*  Address to send to, or null      */
)
</PRE>
<H4>Synopsis</H4>
<P>Replaces the normal write_UDP() function call. The data is
   sent, after a small but significant delay. Returns the length
   of the data packet. There is no guarantee that the packet will
   be sent and received successfully. Returns SOCKET_ERROR if
   there was an error, such as insufficient memory.
<H4>Source Code - (smtsimu.c)</H4>
<PRE>
{
    SOCKREQ *request;                   /*  New socket transfer request      */
    dbyte    req_size;                  /*  Size of transfer request         */
    byte    *msg_body;                  /*  Event to send via delay timer    */
    int      msg_size;                  /*  Size of event body               */
    qbyte    csecs = 100;               /*  Delay time in csecs              */

    /*  Allocate a new transfer request                                      */
    req_size = sizeof (SOCKREQ) + length;
    if ((request = mem_alloc (req_size)) == NULL)
      {
        <A href="smtdoc.htm#sendfmt">sendfmt</A> (&amp;operq, "ERROR", "smtsimu: out of memory");
        return ((int) SOCKET_ERROR);
      }
    request-&gt; id     = ++last_id;
    request-&gt; handle = handle;
    request-&gt; length = length;
    request-&gt; sin    = *sin;
    memcpy ((byte *) request + sizeof (SOCKREQ), buffer, length);

    /*  Calculate size required for message body                             */
    msg_size = exdr_write (
        NULL,                           /*  No body - just get size          */
        SMT_TIME_ALARM,                 /*  Format event for smttime         */
        0, csecs,                       /*  Delay time                       */
        req_size, request);             /*  Request info                     */

    /*  Now allocate and format the buffer                                   */
    msg_body = mem_alloc  (msg_size);
    msg_size = exdr_write (
        msg_body,                       /*  Event body                       */
        SMT_TIME_ALARM,                 /*  Format event for smttime         */
        0, csecs,                       /*  Delay time                       */
        req_size, request);             /*  Request info                     */

    <A href="smtdoc.htm#event_send">event send</A> (
        &amp;timeq,                         /*  Send to specified queue          */
        &amp;simuq,                         /*  No queue for reply               */
        "ALARM",                        /*  Name of event to send            */
        msg_body,                       /*  Event body contents              */
        msg_size,                       /*  Event body size                  */
        NULL, NULL, NULL,               /*  No response events               */
        0);                             /*  No timeout                       */

    mem_free (msg_body);
    mem_free (request);

    if (trace_flag)
        <A href="smtdoc.htm#sendfmt">sendfmt</A> (&amp;operq, "INFO",
                 "smtsimu: packet %u delayed by %u csecs", last_id, csecs);

    return (length);
}
</PRE>
<H2><A NAME="TOC136">The Unattended Process Monitor</A></H2>
<P>Filename: smtupm.h
<BR>Package: Libero SMT 2.x
<BR>Written: 1996/09/10 iMatix SMT kernel team <A
   HREF=mailto:"smt@imatix.com">smt@imatix.com</A>
<BR>Revised: 1997/09/08
<BR>Copyright: Copyright (c) 1991-2000 iMatix Corporation
<H3>Synopsis</H3>
<P>Defines constants, messages, and prototypes for the UPM
   (unattended process monitor) agents.
<H4>List of Functions</H4>
<UL>
<LI>int <A href="smtdoc.htm#smtupmc_init">smtupmc init</A><BR>
   (char *args, char *port);
</LI>
<LI>int <A href="UNDEF">smtupmd init</A><BR>
   (char *inifile, char *port);
</LI>
</UL>
<H4>List of Symbol Definitions</H4>
<P>smtupm.h defines these symbols, possibly conditionally:
<TABLE BORDER NOWRAP>
<TR><TH ALIGN="LEFT">Symbol:  </TH>
    <TH ALIGN="LEFT">Defined as:</TH>
<TR><TD ALIGN="LEFT"><TT><B>SMT_UPMC</B>  </TT>
<TD ALIGN="LEFT">"smtupmc" /* Name of UPM client agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_UPMD</B>  </TT>
<TD ALIGN="LEFT">"smtupmd" /* Name of UPM daemon agent */
<TR><TD ALIGN="LEFT"><TT><B>SMT_UPM_MESSAGE</B>  </TT>
<TD ALIGN="LEFT">"ds"
<TR><TD ALIGN="LEFT"><TT><B>SMT_UPM_PORT</B>  </TT>
<TD ALIGN="LEFT">"5050" /* Port for UPM connection */
<TR><TD ALIGN="LEFT"><TT><B>UPM_ERROR</B>  </TT>
<TD ALIGN="LEFT">201 /* Reply fatal error */
<TR><TD ALIGN="LEFT"><TT><B>UPM_HALT</B>  </TT>
<TD ALIGN="LEFT">101 /* Halt UPM and processes */
<TR><TD ALIGN="LEFT"><TT><B>UPM_HALTING</B>  </TT>
<TD ALIGN="LEFT">202 /* Reply halting UPM */
<TR><TD ALIGN="LEFT"><TT><B>UPM_LIST</B>  </TT>
<TD ALIGN="LEFT">100 /* List processes */
<TR><TD ALIGN="LEFT"><TT><B>UPM_READY</B>  </TT>
<TD ALIGN="LEFT">200 /* Reply ready for command */
<TR><TD ALIGN="LEFT"><TT><B>UPM_START</B>  </TT>
<TD ALIGN="LEFT">102 /* Start-up a process */
<TR><TD ALIGN="LEFT"><TT><B>UPM_START_ERROR</B>  </TT>
<TD ALIGN="LEFT">209 /* Reply task could not be started */
<TR><TD ALIGN="LEFT"><TT><B>UPM_START_OK</B>  </TT>
<TD ALIGN="LEFT">208 /* Reply task started ok */
<TR><TD ALIGN="LEFT"><TT><B>UPM_STATUS</B>  </TT>
<TD ALIGN="LEFT">104 /* Enquire process status */
<TR><TD ALIGN="LEFT"><TT><B>UPM_STOP</B>  </TT>
<TD ALIGN="LEFT">103 /* Shut-down a process */
<TR><TD ALIGN="LEFT"><TT><B>UPM_STOP_ERROR</B>  </TT>
<TD ALIGN="LEFT">211 /* Reply task could not be stopped */
<TR><TD ALIGN="LEFT"><TT><B>UPM_STOP_OK</B>  </TT>
<TD ALIGN="LEFT">210 /* Reply task stopped ok */
<TR><TD ALIGN="LEFT"><TT><B>UPM_TASK_ID</B>  </TT>
<TD ALIGN="LEFT">203 /* Reply task name */
<TR><TD ALIGN="LEFT"><TT><B>UPM_TASK_NF</B>  </TT>
<TD ALIGN="LEFT">205 /* Reply unknown task */
<TR><TD ALIGN="LEFT"><TT><B>UPM_TASK_OK</B>  </TT>
<TD ALIGN="LEFT">204 /* Reply task status */
<TR><TD ALIGN="LEFT"><TT><B>UPM_TASK_RUNNING</B>  </TT>
<TD ALIGN="LEFT">206 /* Reply task is running */
<TR><TD ALIGN="LEFT"><TT><B>UPM_TASK_STOPPED</B>  </TT>
<TD ALIGN="LEFT">207 /* Reply task is not running */
<TR><TD ALIGN="LEFT"><TT><B>_SMTUPM_INCLUDED</B>  </TT>
<TD ALIGN="LEFT">TRUE
</TABLE>
<A NAME="smtupmc_init">&nbsp;</A>
<H3><A NAME="TOC137"><TT>smtupmc_init</TT></A></H3>
<PRE>
#include "smtupm.h"
int
smtupmc_init (char *p_args, char *p_portname)
</PRE>
<H4>Synopsis</H4>
<P>Initialises the SMT UPM client agent. Returns 0 if okay, -1 if
   there was an error. The UPM client agent allows you to pass
   commands to the UPM daemon. See the SMT documentation for
   details.
<H4>Source Code - (smtupmc.c)</H4>
<PRE>
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle to console thread         */
#   include "smtupmc.i"                 /*  Include dialog interpreter       */

    /*  Shutdown event comes from Kernel                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SHUTDOWN", shutdown_event, SMT_PRIORITY_MAX);

    /*  Reply events from socket agent                                       */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_INPUT_OK",  ok_event,          0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_OUTPUT_OK", ok_event,          0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_READ_OK",   ok_event,          0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_WRITE_OK",  ok_event,          0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_CLOSED",    sock_closed_event, 0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_ERROR",     sock_error_event,  0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "SOCK_TIMEOUT",   sock_error_event,  0);

    /*  Reply events from transfer agent                                     */
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_GETF_OK",   ok_event,          0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_PUTF_OK",   SMT_NULL_EVENT,    0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_CLOSED",    sock_closed_event, 0);
    <A href="smtdoc.htm#method_declare">method declare</A> (agent, "TRAN_ERROR",     sock_error_event,  0);

    /*  Create initial, unnamed thread                                       */
    <A href="smtdoc.htm#thread_create">thread create</A> (AGENT_NAME, "");

    /*  Ensure that socket agent is running, else start it up                */
    <A href="smtdoc.htm#smtsock_init">smtsock init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_SOCKET, "")) != NULL)
        sockq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Ensure that transfer agent is running, else start it up              */
    <A href="smtdoc.htm#smttran_init">smttran init</A> ();
    if ((thread = <A href="smtdoc.htm#thread_lookup">thread lookup</A> (SMT_TRANSFER, "")) != NULL)
        tranq = thread-&gt; queue-&gt; qid;
    else
        return (-1);

    /*  Signal okay to caller that we initialised okay                       */
    args     = p_args;                  /*  Get command-line arguments       */
    portname = p_portname;
    return (0);
}
</PRE>
<HR><TABLE WIDTH=100%><TR><TD ALIGN=LEFT WIDTH=60%>
 | <A href="smtdoc.htm">&lt;&lt;</A> | &lt;
 | &gt; | <A href="smtdoc.htm">&gt;&gt;</A>
<TD ALIGN=RIGHT NOWRAP>
<A HREF="/index.htm">
<IMG SRC="im0096c.gif" WIDTH=96 HEIGHT=36 ALT="iMatix" BORDER=0 ALIGN=RIGHT>
</A>
<FONT SIZE=2>Copyright &#169; 1996-99 iMatix Corporation</TABLE>
</BODY></HTML>
