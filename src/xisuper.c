/*  ----------------------------------------------------------------<Prolog>-
    Name:       xisuper.c
    Title:      Xitami supervisor agent
    Package:    Xitami 

    Written:    1999/04/14  iMatix Xitami team <xitami@imatix.com>
    Revised:    1999/06/23

    Synopsis:   Manages temporary and log files.

    Copyright:  Copyright (c) 1991-2000 iMatix Corporation
    License:    This is free software; you can redistribute it and/or modify
                it under the terms of the SMT License Agreement as provided
                in the file LICENSE.TXT.  This software is distributed in
                the hope that it will be useful, but without any warranty.
 ------------------------------------------------------------------</Prolog>-*/

#include "smtdefn.h"                    /*  SMT definitions                  */
#include "smthttpl.h"                   /*  SMTHTTPL prototypes & globals    */


/*- Definitions -------------------------------------------------------------*/

#undef  AGENT_NAME
#define AGENT_NAME       "xisuper"      /*  Our public name                  */
#define SINGLE_THREADED  TRUE           /*  Single-threaded agent            */
#define XISUPER_INTERVAL INTERVAL_HOUR  /*  Activate once per hour           */

local cleanup_directory (char *directory, char *mask, int min_age);


/*- Global variables used in this source file only --------------------------*/

static QID
    operq,                              /*  Operator console event queue     */
    timeq;                              /*  Timer event queue                */

static long
    busy_interval;                      /*  How long have we been waiting?   */
    
#include "xisuper.d"                    /*  Include dialog data              */


/********************   INITIALISE AGENT - ENTRY POINT    ********************/

/*  ---------------------------------------------------------------------[<]-
    Function: xisuper_init

    Synopsis: Initialises the Xitami supervisor agent.  Returns 0 if
    initialised okay, -1 if there was an error.
    ---------------------------------------------------------------------[>]-*/

int
xisuper_init (void)
{
    AGENT   *agent;                     /*  Handle for our agent             */
    THREAD  *thread;                    /*  Handle to console thread         */
#   include "xisuper.i"                 /*  Include dialog interpreter       */

    /*                      Method name    Event value    Priority           */
    /*  Shutdown event comes from Kernel                                     */
    method_declare (agent, "SHUTDOWN",     shutdown_event, SMT_PRIORITY_MAX);

    /*  Alarm event sent by timer to this agent                              */
    method_declare (agent, "TIME_ALARM",   ok_event,       0);

    /*  Ensure that timer agent is running, else start it up                 */
    smttime_init ();
    if ((thread = thread_lookup (SMT_TIMER, "")) != NULL)
        timeq = thread-> queue-> qid;
    else
        return (-1);

    /*  Ensure that operator console is running, else start it up            */
    smtoper_init ();
    if ((thread = thread_lookup (SMT_OPERATOR, "")) != NULL)
        operq = thread-> queue-> qid;
    else
        return (-1);

    /*  Create single master thread                                          */
    thread_create (AGENT_NAME, "main");

    /*  Signal okay to caller that we initialised okay                       */
    return (0);
}


/*************************   INITIALISE THE THREAD   *************************/

MODULE initialise_the_thread (THREAD *thread)
{
    busy_interval  = 0;
    the_next_event = ok_event;
}


/************************   SLEEP FOR AN HOUR OR SO   ************************/

MODULE sleep_for_an_hour_or_so (THREAD *thread)
{
    send_alarm (&timeq, 0, XISUPER_INTERVAL, 0, 0);
}


/***********************   CHECK WHETHER XITAMI BUSY   ***********************/

MODULE check_whether_xitami_busy (THREAD *thread)
{
    if (cur_connects > 0)
      {
        the_next_event = busy_event;
        busy_interval += XISUPER_INTERVAL;
      }
    else
      {
        the_next_event = not_busy_event;
        busy_interval = 0;
      }
}


/*************************   CHECK WHETHER OVERDUE   *************************/

MODULE check_whether_overdue (THREAD *thread)
{
    if (busy_interval > INTERVAL_DAY)
      {
        raise_exception (not_busy_event);
        busy_interval = 0;
      }
}


/***************************   CLEAN UP LOG FILES   **************************/

MODULE clean_up_log_files (THREAD *thread)
{
    SYMBOL
        *symbol;
        
    /*  We get the list of log file directories (potentially a different one
     *  for each virtual host) from the http_dirs symbol table.  We delete
     *  log files older than two weeks.
     */
    for (symbol = http_dirs-> symbols; symbol; symbol = symbol-> next)
        cleanup_directory (symbol-> name, "*.log", 14);
}

static void
cleanup_directory (char *directory, char *mask, int min_age)
{
    DIRST
        dir;
    time_t
        cut_off_point;
    char
        *full_name;
    int
        files_deleted = 0;

    /*  Calculate cut-off point in seconds, as a number of days before NOW   */
    cut_off_point = time (NULL) - min_age * 86400L;
    if (open_dir (&dir, directory)) do
      {
        if ((dir.file_attrs & ATTR_HIDDEN) == 0
        &&  (dir.file_attrs & ATTR_SUBDIR) == 0)
          {
            if (file_matches (dir.file_name, mask)
            &&  dir.file_time < cut_off_point)
              {
                full_name = xstrcpy (NULL, directory, "/", dir.file_name, NULL);
                file_delete (full_name);    
                files_deleted++;
                mem_free (full_name);
              }
          }
      }
    while (read_dir (&dir));
    close_dir (&dir);
    if (files_deleted)
        sendfmt (&operq, "INFO", "%d files deleted in directory '%s'",
                                  files_deleted, directory);
}


/************************   CLEAN UP TEMPORARY FILES   ***********************/

MODULE clean_up_temporary_files (THREAD *thread)
{
    SYMBOL
        *symbol;
        
    /*  We get the list of temp file directories (potentially a different one
     *  for each virtual host) from the http_dirs symbol table.  We delete
     *  temporary files older than one day.
     */
    for (symbol = http_dirs-> symbols; symbol; symbol = symbol-> next)
        cleanup_directory (symbol-> name, "pipe*", 1);
}


/*************************   TERMINATE THE THREAD   **************************/

MODULE terminate_the_thread (THREAD *thread)
{
    the_next_event = terminate_event;
}

